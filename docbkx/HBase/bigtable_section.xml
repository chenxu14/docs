<?xml version="1.0" encoding="UTF-8"?>
<section version="5.0" xmlns="http://docbook.org/ns/docbook"
	xmlns:xlink="http://www.w3.org/1999/xlink"
	xmlns:xi="http://www.w3.org/2001/XInclude"
	xmlns:ns5="http://www.w3.org/2000/svg"
	xmlns:ns4="http://www.w3.org/1998/Math/MathML"
	xmlns:ns3="http://www.w3.org/1999/xhtml"
	xmlns:db="http://docbook.org/ns/docbook">
	<title>BigTable参照</title>
	<para>HBase是参照Google的BigTable体系结构来进行构建的，在很多功能组件的实现上都是以BigTable为原型进行设计，可以说是BigTable的开源“山寨”版本，两者间的组件映射关系如表格所示：</para>
	<table frame='all'>
		<title>HBase与BigTable概念名词对比</title>
		<tgroup cols='3' align='left' colsep='1' rowsep='1'>
			<colspec colname='c1' colwidth="10em"/>
			<colspec colname='c2'/>
			<colspec colname='c3'/>
			<thead>
				<row><entry>描述</entry><entry>HBase定义</entry><entry>BigTable定义</entry></row>
			</thead>
			<tbody>
				<row><entry>表格切片</entry><entry>region</entry><entry>tablet</entry></row>
				<row><entry>元数据表格</entry><entry>.META.</entry><entry>METADATA</entry></row>
				<row><entry>数据文件</entry><entry>StoreFile</entry><entry>SSTable</entry></row>
				<row><entry>分布式文件系统</entry><entry>HDFS</entry><entry>GFS</entry></row>
				<row><entry>分布式锁服务</entry><entry>Zookeeper</entry><entry>Chubby</entry></row>
				<row><entry>master节点</entry><entry>Master</entry><entry>MasterServer</entry></row>
				<row><entry>slave节点</entry><entry>RegionServer</entry><entry>TabletServer</entry></row>
			</tbody>
		</tgroup>	
	</table>
	<para>因此要深入了解HBase的体系结构最好首先熟悉一下BigTable，而有关BigTable最权威的知识介绍无疑是Google对外发布的<ulink url="http://research.google.com/archive/bigtable-osdi06.pdf">BigTable论文</ulink>，所以本章节主要围绕该论文进行介绍。</para>
	<para>从概念视图上来看，BigTable是一种column-oriented类型的数据库，其信息内容可描绘成一张数据表格，但是与传统的关系数据库相比，表格有以下几方面的不同：</para>
	<orderedlist>
		<listitem>
			<para>维度不同</para>
			<para>关系数据库的表格通常都是二维的，通过row和column来确定唯一单元格；而BigTable所描绘的表格却是三维的，除了row和column外，还需要Z轴的时间戳信息才能确定目标单元格，结构对比如图所示：</para>
			<mediaobject>
				<imageobject>
					<imagedata contentdepth="100%" width="100%" scalefit="1" fileref="../media/hbase/table-structure.jpg"></imagedata>
				</imageobject>
			</mediaobject>
		</listitem>
		<listitem>
			<para>Schema描述不同</para>
			<para>关系数据库需要定义出表格的每一个column及其类型，而BigTable不需要这样做，只需定义出ColumnsFamily(列簇)即可，无需对column有特殊定义，而且column还可在表格使用期间动态新增。</para>
		</listitem>	
		<listitem>
			<para>数据规模不同</para>
			<para>BigTable的数据存储量通常都非常庞大，庞大到单台机器满足不了存储需求，因此在存储策略的选择上采用的是对表格数据进行切片的办法，将每一个切片分散到不同的机器上进行分布式存储，处理方式如图所示：</para>
			<mediaobject>
				<imageobject>
					<imagedata contentdepth="100%" width="100%" scalefit="1" fileref="../media/hbase/table-split.jpg"></imagedata>
				</imageobject>
			</mediaobject>
			<tip>
				<para>rowkey的概念类似于关系数据库中的主键，用来唯一标识一条记录。表格数据是通过rowkey来排序的，BigTable通过它来决定记录属于哪个切片。</para>
				<para>在BigTable数据模型中，切片的概念通过tablet来描述，它是表格数据的分布式部署单元。</para>
			</tip>
		</listitem>
	</orderedlist>
	<section>
		<title>数据模型</title>
		<para>从数据结构的角度来看BigTable可转换成一张松散的Map，其中Map的key值用来定位单元格的存储位置，而value值用于封装单元格中的数据内容。键值对的映射关系如下所示：</para>
		<blockquote><para>(row:string, column:string, time:int64) --> string</para></blockquote>
		<orderedlist>
			<listitem>
				<para>其中row表示每行记录的rowkey值</para>
				<para>rowkey的数据量大小不能超过64KB(通常在10~100字节之间最好)，表格的数据在持久化之前先通过rowkey来排序。因此具有相同性质的数据最好指定相似的rowkey值，这样在执行分区的时候能够尽量保证它们处于同一切片(tablet)中，防止数据的跨切片查询，以此提升检索效率。</para>
				<tip><para>执行查询操作时，Map的部分key值是存储在内存里的，因此rowkey的大小会影响内存资源的使用(具体参考HFile存储结构章节)。</para></tip>
			</listitem>
			<listitem>
				<para>column为表格的栏位信息</para>
				<para>BigTable是一种Schema-less型的数据库，column是可在运行期间动态新增的，但前提是必须定义好ColumnFamily。</para>
				<para>ColumnFamily主要用来表示一组具有相同性质的column群体，BigTable针对数据访问权限的控制和资源使用情况的统计都是基于ColumnFamily进行的。</para>
			</listitem>
			<listitem>
				<para>time为时间戳信息</para>
				<para>在实际应用中，时间戳可充当版本的概念，用于检索历史数据。</para>
			</listitem>
		</orderedlist>
	</section>	
	<section>
		<title>依赖组件</title>
		<para>在功能部署上，BigTable并不是作为单独的组件独立运行存在的，其核心的工作离不开其他组件的协调与帮助，组件之间彼此协作从而形成一个功能完善的应用整体，这些组件包括：</para>
		<orderedlist>
			<listitem>
				<para>Google File System</para>
				<para>谷歌分布式文件系统，BigTable主要通过它来完成物理数据的存储，存储办法是将每一个切片(tablet)拆分成多个SSTable文件，再将这些文件保存到文件系统中去。</para>
				<tip><para>SSTable是谷歌针对BigTable设计的文件存储格式，Hbase参照SSTable设计了HFile存储格式，其存储结构与SSTable相似，详细参考HFile存储结构章节。</para></tip>
			</listitem>
			<listitem>
				<para>Chubby框架</para>
				<para>Chubby在BigTable体系中主要扮演着分布式协调工具的角色，如果其名字还比较陌生的话，那么提到开源的Zookeeper或许会有更多的人了解，它们的功能相似，在集群的高可用性以及分布式锁管理上有着突出的作用。BigTable通过Chubby主要实现以下功能：</para>
				<blockquote>
					<itemizedlist make='bullet'>
						<listitem><para>master故障转移，通过Chubby的Leader选举机制；</para></listitem>
						<listitem><para>存储元数据地址信息(参考功能实现章节中的tablet定位)；</para></listitem>
						<listitem><para>管理集群机器节点，监听新节点的加入和已有节点的移除；</para></listitem>
						<listitem><para>存储表格的ColumnFamily定义以及针对ColumnsFamily设置的访问控制列表。</para></listitem>
					</itemizedlist>
				</blockquote>
				<para>Chubby中存储的数据会以水平扩充的方式进行备份，从而将系统出错的可能性将至最低。</para>
			</listitem>
		</orderedlist>
	</section>
	<section>
		<title>部署结构</title>
		<para>BigTable主要基于master/slave方式进行部署(主仆结构)，其中MasterServer充当主人的角色，而TabletServer充当仆人的角色，部署结构见下图：</para>
		<mediaobject>
			<imageobject>
				<imagedata contentdepth="100%" width="80%" scalefit="1" fileref="../media/hbase/deploy-architecture.jpg"></imagedata>
			</imageobject>
		</mediaobject>
		<para>组件的作用描述如下：</para>
		<orderedlist>
			<listitem>
				<para>TabletServer</para>
				<para>TabletServer作为仆人主要负责管理MasterServer分配给它的tablet，同时响应客户端对tablet的读写请求。随着写请求次数的增多，Tablet数据量也会日益增长，当增长量达到一定规模时，TabletServer还会负责将其进行拆分。</para>
			</listitem>
			<listitem>
				<para>MasterServer</para>
				<para>MasterServer作为主人主要有以下几项功能职责：</para>
				<blockquote>
					<para>(1)将tablet分配给TabletServer；</para>
					<para>(2)监听TabletServer的运行状态；</para>
					<para>(3)对TabletServer实现负载均衡；</para>
					<para>(4)清理垃圾数据；</para>
					<para>(5)管理表格的Schema定义。</para>
				</blockquote>
				<para>系统中可能会存在多个master节点，但是这些节点并不会同时运行，而是处于一个竞争的状态，当处于Active状态的master节点出现故障的时候，系统会转移到其他master来接管，这个过程是通过Chubby来实现的。</para>
			</listitem>
			<listitem>
				<para>ClientLibrary</para>
				<para>客户端通过它来与TabletServer进行通信，完成读写逻辑，同时缓存已读取到的Tablet地址，加快下次访问效率。</para>
				<para>客户端对TabletServer的访问是通过Chubby(不是MasterServer)来定位的，因此客户端需要有Chubby的连接环境，否则会找不到TabletServer。</para>
			</listitem>
		</orderedlist>
	</section>
	<section>
		<title>功能实现</title>
		<para>功能实现是整个BigTable体系中最有价值的一个环节，一些核心的设计理念和实现方法都是通过它来体现的。有关实现的细节部分将会在第二章组件实现章节中进行详细的介绍，而这里只给出大体实现，以方便读者能够对BigTable体系有个抽象的认识。</para>
		<section>
			<title>Tablet定位</title>
			<para>Tablet的定位逻辑主要是通过三层目录结构来呈现的，具体逻辑如图所示：</para>
			<mediaobject>
				<imageobject>
					<imagedata contentdepth="100%" width="80%" scalefit="1" fileref="../media/hbase/tablet-location.jpg"></imagedata>
				</imageobject>
			</mediaobject>
			<para>图示说明：</para>
			<orderedlist>
				<listitem><para>用户自定义的表格(UserTable)处于最底层的叶子节点，这些表格在物理层面上被拆分成多个tablet，每一个tablet的存储地址保存在METADATA表格中；</para></listitem>
				<listitem><para>METADATA是系统预定义的表格，用来存储每一个tablet的地址，其数据存储方式与其他表格类似，需要进行切片处理；</para></listitem>
				<listitem>
					<para>表格是通过rowkey来进行切片的，METADATA表格将rowkey设计成如下格式：</para>
					<blockquote><para>rowkey = tableIdentifier + endRow</para></blockquote>
					<para>这样，如果tableIdentifier为METADATA，那么这些rowkey所对应的记录便组成了一个特殊的tablet，即图中的Root-tablet。</para>
					<para>Root-tablet用来存储METADATA表格中其他tablet的地址，处于目录层级的顶层，通过它可以遍历到所有tablet。</para>
				</listitem>
				<listitem>Root-tablet的存储地址是通过Chubby来保存的，客户端在执行数据定位前，首先需要连接到Chubby来获取该tablet，然后依次向下层级递归，找到需要的数据。</listitem>
			</orderedlist>
		</section>
		<section>
			<title>Tablet分配</title>
			<para>tablet是由MasterServer负责分配给TabletServer的，tablet分配成功以后，所有对该tablet的访问操作全部交由管理它的TabletServer来处理，而MasterServer不在进行参与。</para>
			<tip>
				<para>在提到分配一词时，首先不要产生歧义，MasterServer分配给TabletServer的只是tablet的管理权限，而不是tablet的数据内容，tablet数据是存储在GFS里的，而不是保存在TabletServer上面。</para>
			</tip>
			<para>MasterServer启动以后，会执行以下操作来完成tablet的分配处理：</para>
			<orderedlist>
				<listitem><para>首先通过Chubby来获取目前存活的TabletServer节点；</para></listitem>
				<listitem><para>和每一个TabletServer进行通信，获取它们所管理的tablet信息，组成tablet已分配列表；</para></listitem>
				<listitem><para>扫描METADATA表格，如果有记录不在已分配列表里，则对其进行分配处理，分配的同时需要考虑每个TabletServer节点的负载情况，做使用均衡；</para></listitem>
				<listitem><para>tablet成功分配以后更新METADATA表格以便Client查询获取。</para></listitem>
			</orderedlist>
			<para>与此同时，还需要考虑TableServer宕机的现象，一旦TabletServer-A死掉它所管理的tablet需要重新进行分配。MasterServer通过Chubby可以很容易在第一时间得到TabletServer-A宕机的反馈，然后扫描METADATA表格，将分配给TabletServer-A的切片做重新的分配处理。</para>
		</section>
		<section>
			<title>Tablet读写</title>
			<para>在了解tablet读写流程之前，有必要先熟悉一下tablet存储结构，在物理层面上tablet是由多个SSTable组成的，SSTable是谷歌针对BigTable设计的文件存储格式，其内部是分块存储的，每个块的大小默认为64KB，存储着表格的一些记录，组织关系见下图：</para>
			<mediaobject>
				<imageobject>
					<imagedata contentdepth="100%" width="70%" scalefit="1" fileref="../media/hbase/tablet-store.jpg"></imagedata>
				</imageobject>
			</mediaobject>
			<para>SSTable是基于“一次写入多次读取”的方针来进行设计的，文件内容一旦保存便只能读取和删除而不能修改，因此文件数据通常是大规模批量写入的，写入磁盘之前可先将数据缓存到内存里，当内存数据达到一定规模时在flush到硬盘上。</para>
			<para>数据保存在内存中便会有遗失的风险，为此BigTable采用内存数据库普遍的处理方式，记录操作日志。日志是持久化在GFS上的，一旦内存数据遗失，便可通过日志文件记录的操作来将数据还原。</para>
			<para>了解以上内容之后再看tablet读写：</para>
			<mediaobject>
				<imageobject>
					<imagedata contentdepth="100%" width="70%" scalefit="1" fileref="../media/hbase/tablet-rw.jpg"></imagedata>
				</imageobject>
			</mediaobject>
			<orderedlist>
				<listitem>
					<para>写操作</para>
					<para>当写操作到达时系统首先记录写操作日志到tablet-log,然后将数据内容写入memtable(内存)，当memtable数据量积攒到一定规模时，创建SSTable文件来持久化memtable中的数据。</para>
					<para>如果TabletServer在管理tablet期间出现宕机，则没有完成持久化的内存数据将会遗失，MasterServer负责重新分配这些tablet，tablet重新分配以后，根据已有SSTables和tablet-log可以很容易的将数据恢复到最新状态。</para>
				</listitem>
				<listitem>
					<para>读操作</para>
					<para>tablet数据源存储在两个物理媒介中：磁盘和内存，因此，查询操作需要同时检索memtable和SSTable，并对查询结果进行合并。</para>
				</listitem>
			</orderedlist>
		</section>
		<section>
			<title>数据合并</title>
			<para>由于SSTable文件是不可修改的，因此所有对数据库的更新操作都是以追加记录的方式进行的。这样，随着数据库使用时间的日益增长和写操作的频繁进行，针对同一条数据可能会产生多条记录，在执行查询操作时需要根据时间戳信息来将这些记录进行合并，以便产生最新状态的数据。</para>
			<para>如果要合并的记录比较多，那么无疑会增加查询开销，为此，BigTable提供了数据自动合并的功能，会定期对SSTables进行合并，合并记录的同时也会清理在逻辑上已被删除的数据，这样不但能加快了查询效率，也节省了磁盘空间。</para>
		</section>
	</section>
	<section>
		<title>小结</title>
		<para>本小节主要从数据模型、依赖组件、部署结构和功能实现几个方面对BigTable框架体系做了简短介绍，其中大部分内容参考至BigTable论文和HBase的官方文档，意在帮助读者初步了解HBase框架，从而为下一步的深入学习做好准备，在接下来的一节中主要讲解HBase在存储方面的实现。</para>
	</section>
</section>