<?xml version="1.0" encoding="UTF-8"?>
<section version="5.0" xmlns="http://docbook.org/ns/docbook"
	xmlns:xlink="http://www.w3.org/1999/xlink"
	xmlns:xi="http://www.w3.org/2001/XInclude"
	xmlns:ns5="http://www.w3.org/2000/svg"
	xmlns:ns4="http://www.w3.org/1998/Math/MathML"
	xmlns:ns3="http://www.w3.org/1999/xhtml"
	xmlns:db="http://docbook.org/ns/docbook">
	<title>AppAttempt状态机</title>
	<para>AppAttempt状态机主要用来描绘ResourceManager部署App时的状态转换，状态图如下所示：</para>
	<mediaobject>
		<imageobject>
			<imagedata contentdepth="100%" width="100%" scalefit="1" fileref="../media/yarn/appAttemp-lifecycle.png"></imagedata>
		</imageobject>
	</mediaobject>
	<itemizedlist make='bullet'>
		<listitem>
			<para>状态转换：NEW-->SUBMITTED</para>
			<para>触发事件：START(RMApp加入到调度队列以后会级联触发该事件，开始尝试部署AM)</para>
			<para>回调处理：通过AttemptStartedTransition类来封装。</para>
			<blockquote>
				<para>首先将当前RMAppAttempt状态机实例注册到ApplicationMasterService服务容器中(通过调用其registerAppAttempt方法)；然后触发APP_ATTEMPT_ADDED事件，使调度器进行处理。</para>
			</blockquote>
		</listitem>
		<listitem>
			<para>状态转换：NEW-->FINISHED | KILLED | FAILED | LAUNCHED</para>
			<para>触发事件：RECOVER(对RMApp执行recover操作时会触发该事件)</para>
			<para>回调处理：通过AttemptRecoveredTransition类来封装，具体参考作业恢复事件流。</para>
		</listitem>
		<listitem>
			<para>状态转换：SUBMITTED-->SCHEDULED</para>
			<para>触发事件：ATTEMPT_ADDED(调度器处理完APP_ATTEMPT_ADDED事件时触发)</para>
			<para>回调处理：通过ScheduleTransition类来封装。</para>
			<blockquote>
				<para>构造ResourceRequest用于申请AMContainer，并注入到调度器中进行处理(通过调用其allocate方法)。</para>
			</blockquote>
		</listitem>
		<listitem>
			<para>状态转换：SCHEDULED-->ALLOCATED_SAVING</para>
			<para>触发事件：CONTAINER_ALLOCATED(调度器成功分配AMContainer时触发)</para>
			<para>回调处理：通过AMContainerAllocatedTransition类来封装。</para>
			<blockquote>
				<para>获取调度器新分配的AMContainer并与RMAppAttempt进行绑定。然后将该RMAppAttempt实例保存到RMStateStore中进行存储。</para>
			</blockquote>
		</listitem>
		<listitem>
			<para>状态转换：ALLOCATED_SAVING-->ALLOCATED</para>
			<para>触发事件：ATTEMPT_NEW_SAVED(RMStateStore成功保存RMAppAttempt时触发)</para>
			<para>回调处理：通过AttemptStoredTransition类来封装。</para>
			<blockquote>
				<para>触发AMLauncherEvent事件，事件类型为LAUNCH，用来执行AMContainer的加载操作(详细参考AMContainer加载章节)。</para>
			</blockquote>
		</listitem>
		<listitem>
			<para>状态转换：ALLOCATED-->LAUNCHED</para>
			<para>触发事件：LAUNCHED</para>
			<blockquote><para>执行AMContainer加载操作之后触发该事件(注意：触发该事件的时候AMContainer未必已经成功加载，因为ContainerManager服务的startContainers方法是异步执行的)。</para></blockquote>
			<para>回调处理：通过AMLaunchedTransition类来封装。</para>
			<blockquote>
				<para>通过AMLivelinessMonitor来监控目标AMContainer是否存活。</para>
			</blockquote>
		</listitem>
		<listitem>
			<para>状态转换：LAUNCHED-->RUNNING</para>
			<para>触发事件：REGISTERED</para>
			<blockquote><para>AM成功注册时触发该事件，通过调用ApplicationMasterService类的registerApplicationMaster方法。</para></blockquote>
			<para>回调处理：通过AMRegisteredTransition类来封装。</para>
			<blockquote>
				<para>触发RMAppEvent事件，事件类型为ATTEMPT_REGISTERED，将RMApp的运行状态切换成RUNNING。</para>
			</blockquote>
		</listitem>
		<listitem>
			<para>状态转换：RUNNING-->RUNNING</para>
			<para>触发事件：CONTAINER_ALLOCATED(调度器成功分配TaskContainer时触发)</para>
			<para>回调处理：不做任何处理。</para>
		</listitem>
		<listitem>
			<para>状态转换：RUNNING-->RUNNING</para>
			<para>触发事件：STATUS_UPDATE(AM与RM心跳通信时触发)</para>
			<para>回调处理：通过StatusUpdateTransition类来封装。</para>
			<blockquote>
				<para>调用AMLivelinessMonitor服务的receivedPing方法，向其告知目前AM正处于存活状态。</para>
			</blockquote>
		</listitem>
		<listitem>
			<para>状态转换：RUNNING-->RUNNING | FINAL_SAVING</para>
			<para>触发事件：CONTAINER_FINISHED(Container运行结束时触发，参考RMContainer状态机)</para>
			<para>回调处理：通过ContainerFinishedTransition类来封装。</para>
			<blockquote>
				<para>如果运行结束的Container是AMContainer，构造ApplicationAttemptState用于封装当前RMAppAttempt的运行状态(FAILED)，并将其保存到RMStateStore中进行存储，然后将状态机跳转至FINAL_SAVING状态。</para>
				<para>如果运行结束的Container是TaskContainer，将其加入到RMAppAttempt的已完成集合中，状态机的state保持不变。</para>
			</blockquote>
		</listitem>
		<listitem>
			<para>状态转换：RUNNING-->FINAL_SAVING</para>
			<para>触发事件：UNREGISTERED</para>
			<blockquote>
				<para>AM注销时触发该事件，通过调用ApplicationMasterService的finishApplicationMaster方法。</para>
			</blockquote>
			<para>回调处理：通过AMUnregisteredTransition类来封装。</para>
			<blockquote>
				<para>首先构造ApplicationAttemptState用于封装当前RMAppAttempt的运行状态(FINISHED)，并将其保存到RMStateStore中进行存储，</para>
				<para>然后触发RMAppEvent事件，事件类型为ATTEMPT_UNREGISTERED，使RMApp状态机进行相应的处理。</para>
			</blockquote>
		</listitem>
		<listitem>
			<para>状态转换：RUNNING-->FINAL_SAVING</para>
			<para>触发事件：EXPIRE(AMLivelinessMonitor检测超时的时候会触发该事件)</para>
			<para>回调处理：通过FinalSavingTransition类来封装。</para>
			<blockquote>
				<para>构造ApplicationAttemptState用于封装当前RMAppAttempt的运行状态(FAILED)，并将其保存到RMStateStore中进行存储，</para>
			</blockquote>
		</listitem>
		<listitem>
			<para>状态转换：FINAL_SAVING-->FINISHING | FAILED</para>
			<para>触发事件：ATTEMPT_UPDATE_SAVED(ApplicationAttemptState成功保存后触发该事件)</para>
			<para>回调处理：通过FinalStateSavedTransition类来封装。</para>
			<blockquote>
				<para>首先判断RMAppAttempt进入FINAL_SAVING状态的原因：</para>
				<para>(1)如果是由于AMContainer异常结束引起的(触发CONTAINER_FINISHED事件)，调用AMContainerCrashedAtRunningTransition进行处理，处理过程中会记录诊断信息并将状态机实例切换至FAILED状态。</para>
				<para>(2)如果是由于AMContainer心跳超时引起的(触发EXPIRE事件)，调用ExpiredTransition进行处理，同样记录诊断信息并将状态机切换至FAILED状态。</para>
				<para>(3)如果是由于AM注销引起的(触发UNREGISTERED事件)，调用FinalStateSavedAfterAMUnregisterTransition进行处理，将状态机实例切换至FINISHING状态。</para>
			</blockquote>
		</listitem>
		<listitem>
			<para>状态转换：FINISHING-->FINISHED</para>
			<para>触发事件：CONTAINER_FINISHED(Container运行结束时触发，参考RMContainer状态机)</para>
			<para>回调处理：通过AMFinishingContainerFinishedTransition类来封装。</para>
			<blockquote>
				<para>如果是AMContainer运行结束，调用FinalTransition进行处理，处理内容如下：</para>
				<para>(1)将当前RMAppAttempt从ApplicationMasterService服务容器中移除，通过调用其unregisterAttempt方法；</para>
				<para>(2)触发ATTEMPT_FINISHED事件使RMApp状态机进行相应处理；</para>
				<para>(3)触发APP_ATTEMPT_REMOVED事件使调度器进行相应处理；</para>
				<para>(4)放弃对目标AM的监控操作，通过调用AMLivelinessMonitor的unregister方法，并触发CLEANUP事件来使AMLauncher做清理工作(通过调用ContainerManager服务的stopContainers方法来杀死目标AMContainer进程)。</para>
			</blockquote>
		</listitem>
	</itemizedlist>
</section>