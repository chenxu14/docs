<?xml version="1.0" encoding="UTF-8"?>
<section version="5.0" xmlns="http://docbook.org/ns/docbook"
	xmlns:xlink="http://www.w3.org/1999/xlink"
	xmlns:xi="http://www.w3.org/2001/XInclude"
	xmlns:ns5="http://www.w3.org/2000/svg"
	xmlns:ns4="http://www.w3.org/1998/Math/MathML"
	xmlns:ns3="http://www.w3.org/1999/xhtml"
	xmlns:db="http://docbook.org/ns/docbook">
	<title>ResourceManager组件</title>
	<para>ResourceManager是YARN框架最为核心的服务组件，当我们执行以下命令时</para>
	<para>$ $HADOOP_YARN_HOME/sbin/yarn-daemon.sh --config $HADOOP_CONF_DIR start resourcemanager</para>
	<para>其实是在执行ResourceManager的main方法，来启动资源管理服务。</para>
	<para>该服务继承至CompositeService，是一个组合服务，其内部封装了一个服务列表，包括：</para>
	<itemizedlist make='bullet'>
		<listitem><para>AsyncDispatcher：事件触发器服务</para></listitem>
		<listitem><para>ContainerAllocationExpirer：监控Container的分配是否成功，默认情况下如果超过10分钟没有分配成功，则触发SchedulerEventType.CONTAINER_EXPIRED事件，让ResourceScheduler做相应处理(时间通过yarn.resourcemanager.rm.container-allocation.expiry-interval-ms属性进行配置)</para></listitem>
		<listitem><para>AMLivelinessMonitor：监控ApplicationMaster是否工作正常，默认情况下，如果ResourceManager超过10分钟没有收到ApplicationMaster的心跳响应，则认为该ApplicationMaster出现了问题，放弃处理(时间通过yarn.am.liveness-monitor.expiry-interval-ms属性来配置)</para></listitem>
		<listitem><para>NMLivelinessMonitor：监控NodeManager是否工作正常，默认情况下，如果ResourceManager超过10分钟没有收到NodeManager的心跳响应，则认为该NodeManager出现了问题(时间通过yarn.nm.liveness-monitor.expiry-interval-ms属性进行配置)</para></listitem>
		<listitem><para>DelegationTokenRenewer：通过该服务来延长DelegationToken的使用时间</para></listitem>
		<listitem><para>NodesListManager：处理NodesListManagerEventType事件类型</para></listitem>
		<listitem><para>SchedulerEventDispatcher：处理SchedulerEventType类型的事件并调用ResourceScheduler响应事件处理(参考调度器)。</para></listitem>
		<listitem><para>SchedulingMonitor：</para></listitem>
		<listitem><para>ResourceTrackerService：RPC服务，用于ResourceManager和NodeManager之间进行交互(参考ResourceTracker服务)</para></listitem>
		<listitem><para>ApplicationMasterService：RPC服务，用于ResourceManager和ApplicationMaster之间进行交互</para></listitem>
		<listitem><para>ClientRMService：RPC服务，用于ResourceManager和YarnClient之间进行交互</para></listitem>
		<listitem><para>AdminService：</para></listitem>
		<listitem><para>ApplicationMasterLauncher：该服务用于启动加载ApplicationMaster</para></listitem>
	</itemizedlist>
	<para>同时ResourceManager还提供了一个上下文对象(RMContext)用于在这些服务之间共享数据和资源</para>
	<mediaobject>
		<imageobject>
			<imagedata contentdepth="100%" width="100%" scalefit="1" fileref="../media/yarn/RM-Service.jpg"></imagedata>
		</imageobject>
	</mediaobject>
	<xi:include href="scheduler_section.xml" />
	<section>
		<title>ApplicationClientProtocol服务</title>
	</section>
	<section>
		<title>ApplicationMasterService服务</title>
		<para>ApplicationMasterService主要用于封装AM和RM组件之间的心跳通信逻辑，心跳内容涉及两个方面，分别是：ApplicationMaster注册和Container计算资源申请。服务部署在RM端，AM端通过其代理服务进行RPC引用。</para>
		<itemizedlist make='bullet'>
			<listitem>
				<para>ApplicationMaster注册</para>
				<para>ApplicationMaster注册是通过registerApplicationMaster方法来实现的，注册过程中主要完成以下逻辑：</para>
				<orderedlist>
					<listitem><para>首先调用AMLivelinessMonitor服务的receivedPing方法，向其告知目前AM正处于存活状态；</para></listitem>
					<listitem><para>然后触发RMAppAttemptEvent事件，事件类型为REGISTERED，将RMAppAttempt状态机切换成Running状态(参考RMAppAttempt状态机)；</para></listitem>
					<listitem><para>最后返回RegisterApplicationMasterResponse实例来响应AM的注册申请，封装的信息包括：调度器配置的Container最大分配内存、app访问控制列表(acl信息)及令牌信息(如果启用kerberos认证)。</para></listitem>
				</orderedlist>
			</listitem>
			<listitem>
				<para>Container计算资源申请(心跳通信)</para>
				<para>ApplicationMaster启动后，需要为当前作业的每一个Task来申请Container计算资源，申请逻辑是通过allocate方法来封装的，方法参数包含了以下几个方面的信息：</para>
				<blockquote>
					<para>(1)当前作业的执行进度；</para>
					<para>(2)用于申请Container的ResourceRequest集合；</para>
					<para>(3)需要释放资源的Container集合；</para>
					<para>(4)黑名单列表。</para>
				</blockquote>
				<para>这些信息的构建可参考MapReduce应用中的ContainerAllocator服务，ApplicationMasterService收到这些信息后开始执行如下处理：</para>
				<orderedlist>
					<listitem><para>首先调用AMLivelinessMonitor服务的receivedPing方法，向其告知目前AM正处于存活状态；</para></listitem>
					<listitem>
						<para>然后检测目标AM是否满足如下约束条件：</para>
						<para>(1)目标AM所属App已开启了RMAppAttempt状态机实例，并成功注册到ApplicationMaster服务中(通过调用其registerAppAttempt方法)，否则方法将抛出ApplicationAttemptNotFoundException异常；</para>
						<para>(2)AM已经成功注册(通过调用当前服务的registerApplicationMaster方法)，如果没有方法将抛出ApplicationMasterNotRegisteredException异常；</para>
						<para>(3)AM端的心跳申请没有出现滞后的现象，否则抛出InvalidApplicationMasterRequestException异常。</para>
					</listitem>
					<listitem><para>接着触发RMAppAttemptEvent事件，事件类型为STATUS_UPDATE，将作业进度信息传递至RMAppAttempt状态机，以便其更新自身进度；</para></listitem>
					<listitem><para>最后调用YarnScheduler的allocate方法，将ResourceRequest注入到调度器中进行处理(参考Scheduler资源调度器)。</para></listitem>
					<listitem>
						<para>待调度器处理完成后，发送response响应给AM，response信息包括：</para>
							<para>(1)调度器新分配的Container信息；</para>
							<para>(2)运行状况发生变动的NM节点(这些节点通过NodeListManager服务进行维护)；</para>
							<para>(3)RM端已运行结束的Container信息；</para>
							<para>(4)限制该Application能够使用的总资源量(功能尚未启用)；</para>
							<para>(5)集群现有的NM节点数；</para>
							<para>(6)资源抢占情况？TODO</para>
						<para>响应信息发送后，AM端的后续处理可参考ContainerAllocator服务。</para>
					</listitem>
				</orderedlist>
			</listitem>
		</itemizedlist>
	</section>
	<section>
		<title>ResourceTrackerService服务</title>
		<para>ResourceTracker作为RPC服务主要用于RM和NM之间的通信，服务发布在RM端，NM端通过其代理服务来与RM进行交互，交互内容有：NM注册以及心跳通信逻辑。</para>
		<orderedlist>
			<listitem>
				<para>NodeManager注册；</para>
				<para>NM注册是通过registerNodeManager方法来实现的，在NodeManager启动时会触发该方法的执行，方法参数为RegisterNodeManagerRequest，所封装的信息包括：</para>
				<itemizedlist make='bullet'>
					<listitem><para>计算机的节点ID(由host和port组成)；</para></listitem>
					<listitem>
						<para>计算机可对外提供的计算资源(总内存数和总处理器数)；</para>
						<para>内存数通过yarn.nodemanager.resource.memory-mb属性来配置，默认为8G；</para>
						<para>处理器数通过yarn.nodemanager.resource.cpu-vcores属性来配置，默认为8；</para>
					</listitem>
					<listitem><para>计算机对外提供服务的端口。</para></listitem>
				</itemizedlist>
				<para>执行注册前，服务首先判断要注册的NM节点是否存在于yarn.resourcemanager.nodes.exclude-path配置中，如果存在则放弃注册处理；同时还要检验NM对外提供的资源总大小能否满足单个Container的最低分配要求，如果不能同样放弃处理；</para>
				<para>然后校验目标NM是否之前已经注册过(比如NM端执行了resync操作)，如果条件满足触发RECONNECTED事件，使RMNode状态机做回调处理。</para>
				<para>以上校验通过后，触发RMNodeEvent事件，事件类型为STARTED，使RMNode状态机做相应处理。</para>
				<tip>服务端收到注册请求之后，根据其封装的信息来构建RMNode对象用于表示该计算机节点，并将其注入到RMContext容器。注册成功后，ResourceManager便知道了该计算机的地址和所能提供的计算资源。这样，当所有的计算机节点成功注册后，ResourceManager便能计算出整个集群的资源(总内存和总处理器数)。</tip>
			</listitem>
			<listitem>
				<para>心跳通信</para>
				<para>心跳通信逻辑是通过NodeStatusUpdater服务来开启的(参考NodeStatusUpdater)，每次心跳NM端都会执行ResourceTracker服务的nodeHeartbeat方法，来向RM汇报每一个NMContainer的运行状态，RM收到这些信息后执行如下回调处理：</para>
				<itemizedlist make='bullet'>
					<listitem><para>首先判断当前心跳的NM节点是否已经成功注册到RM中，如果没有通知其执行resync操作；</para></listitem>
					<listitem><para>调用NMLivelinessMonitor服务的receivedPing方法，向其通知目前NM处于存活状态；</para></listitem>
					<listitem><para>判断当前心跳的NM节点是否在于yarn.resourcemanager.nodes.exclude-path配置里，如果是通知其执行shutDown操作，同时触发RMNodeEvent事件，事件类型为DECOMMISSION，使RMNode状态机做相应处理；</para></listitem>
					<listitem><para>判断目标NM的心跳响应是否存在积压(比如NM端发送3次心跳申请，但是RM端只有一次心跳响应)，如果存在积压同样通知其进行resync处理(resync的处理细节参考NodeStatusUpdater服务)。</para></listitem>
					<listitem><para>触发RMNodeEvent事件，事件类型为STATUS_UPDATE，将NM传递过来的状态信息(节点健康情况，已分配Container的运行状态，正在运行的AM)发送给RMNode状态机进行处理；</para></listitem>
				</itemizedlist>
				<para>RM处理完成之后，会发送如下响应信息到NM端进行处理：</para>
				<blockquote>
					<para>(1)待清理的Container集合(RMContainer已结束，但NMContainer还未结束的)，集合的构建过程可参考RMNode状态机的CLEANUP_CONTAINER事件处理；</para>
					<para>(2)待清理的App集合(RMApp已运行结束，但Application还未结束的)，集合的构建过程可参考RMNode状态机的CLEANUP_APP事件处理；</para>
				</blockquote>	
			</listitem>
		</orderedlist>
	</section>
	<section>
		<title>NodesListManager服务</title>
		<para>NodeListManager服务主要用于管理运行状况发生变动的NM节点，比如当NM的健康状态发生改变时，或NM加入/移除yarn.resourcemanager.nodes.exclude-path配置时，都会触发相应的事件来使该服务做相应的回调处理，事件类型为NodesListManagerEventType，可用枚举包括NODE_USABLE(NM可用)和NODE_UNUSABLE(NM不可用)。</para>
		<para>处理过程主要是触发RMAppEvent事件，事件类型为NODE_UPDATE，来将运行状态发生变动的NM节点通知给每一个RMApp实体，等到AM和RM心跳通信时在将这些节点作为response返回给AM进行处理(参考ApplicationMasterService服务)。</para>
	</section>
</section>