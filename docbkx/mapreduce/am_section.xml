<?xml version="1.0" encoding="UTF-8"?>
<section version="5.0" xmlns="http://docbook.org/ns/docbook"
	xmlns:xlink="http://www.w3.org/1999/xlink"
	xmlns:xi="http://www.w3.org/2001/XInclude"
	xmlns:ns5="http://www.w3.org/2000/svg"
	xmlns:ns4="http://www.w3.org/1998/Math/MathML"
	xmlns:ns3="http://www.w3.org/1999/xhtml"
	xmlns:db="http://docbook.org/ns/docbook">
	<title>ApplicationMaster组件</title>
	<section>
		<title>MRAppMaster服务</title>
		<para>MRAppMaster服务是通过ContainersLauncher来启动的(参考ContainersLancher)，其作为MapReduce应用的ApplicationMaster主要负责为TaskContainer申请计算资源，并为每个TaskContainer分配计算任务。</para>
		<para>一、当服务初始化时，执行如下处理：</para>
		<orderedlist>
			<listitem><para>初始化AppContext上下文对象；</para></listitem>
			<listitem>
				<para>添加子服务完成相关业务，子服务包括：</para>
				<itemizedlist make='bullet'>
					<listitem>
						<para>Dispatcher：事件触发器服务；</para>
					</listitem>
					<listitem>
						<para>Speculator：推测执行服务；</para>
					</listitem>
					<listitem>
						<para>ContainerAllocator：</para>
					</listitem>
					<listitem>
						<para>CommitterEventHandler：</para>
					</listitem>
					<listitem>
						<para>TaskAttemptListener：</para>
					</listitem>
					<listitem>
						<para>JobHistoryEventHandler：</para>
					</listitem>
					<listitem>
						<para>ContainerLauncher：执行TaskContainer加载操作；</para>
					</listitem>
				</itemizedlist>
			</listitem>
			<listitem>
				<para>注册事件处理器，响应事件处理：</para>
				<itemizedlist make='bullet'>
					<listitem>
						<para>注册JobEventDispatcher用来响应JobEventType事件类型；</para>
						<para>首先由事件对象获取到Job实例，在将事件转交给Job状态机进行处理。</para>
					</listitem>
					<listitem><para>注册TaskEventDispatcher用来响应TaskEventType事件类型；</para></listitem>
					<listitem><para>注册TaskAttemptEventDispatcher用来响应TaskAttemptEventType事件类型；</para></listitem>
					<listitem>
						<para>注册CommitterEventHandler用来响应CommitterEventType事件类型；</para>
						<para>针对每一个事件开启EventProcessor线程来做响应处理。</para>
					</listitem>
					<listitem>
						<para>注册SpeculatorEventDispatcher用来响应Speculator.EventType事件类型；</para>
						<para>首先判断系统是否开启了推测执行功能，如果是，将事件转发给Speculator进行处理(参考Speculator)。</para>
						<tip>推测执行功能默认是开启的，可通过mapreduce.map.speculative参数和mapreduce.reduce.speculative参数来控制是否开启</tip>
					</listitem>
					<listitem><para>注册ContainerAllocator用来响应ContainerAllocator.EventType事件类型；</para></listitem>
					<listitem><para>注册ContainerLauncher用来响应ContainerLauncher.EventType事件类型；</para></listitem>
					<listitem><para>注册JobHistoryEventHandler用来响应jobhistory.EventType事件类型。</para></listitem>
				</itemizedlist>
			</listitem>
		</orderedlist>
		<para>二、当服务启动时，执行如下处理：</para>
			<para>首先。对运行错误的AM执行recovery操作</para>
			<tip>recovery功能默认开启，通过yarn.app.mapreduce.am.job.recovery.enable参数来配置</tip>
			<para>创建org.apache.hadoop.mapreduce.v2.app.job.Job实例并加入到AppContext上下文环境中；</para>
			<para>注册JobFinishEventHandler用来响应JobFinishEvent.Type事件类型</para>
			<para>触发JobHistoryEvent事件，事件类型为AM_STARTED，使JobHistoryEventHandler做相应处理(参考JobHistoryEventHandler)</para>
			<para>触发JobEventType.JOB_INIT事件，完成Job初始化操作(参考Job状态机)；</para>
			<para>触发SpeculatorEvent事件，使SpeculatorEventDispatcher做相应处理；</para>
			<para>启动MRClientProtocol RPC服务响应jobClient请求</para>
			<para>触发JobEventType.JOB_START事件，开始运行Job实例(参考Job状态机)，</para>
		<section>
			<title>ContainerAllocator服务</title>
			<para>ContainerAllocator服务用于为Task申请Container计算资源，针对作业运行方式的不同，框架声明了多种不同的实现类来做相应的处理：</para>
			<blockquote>
				<itemizedlist make='bullet'>
					<listitem><para>如果作业以uber方式运行，使用LocalContainerAllocator；</para></listitem>
					<listitem><para>如果以非uber方式运行，使用RMContainerAllocator。</para></listitem>
				</itemizedlist>
			</blockquote>
			<para>两种实现类全部继承至RMCommunicator服务，该服务在启动时做如下处理：</para>
			<orderedlist>
				<listitem><para>首先通过ClientRMProxy来创建ApplicationMasterService代理服务；</para></listitem>
				<listitem><para>然后通过代理服务的registerApplicationMaster方法将ApplicationMaster进行注册(参考ApplicationMasterService)；</para></listitem>
				<listitem>
					<para>最后开启心跳通信线程，通过心跳逻辑来完成Container计算资源的申请，如图所示：</para>
					<mediaobject>
						<imageobject>
							<imagedata contentdepth="75%" scalefit="1" fileref="../media/yarn/containerAllocator.jpg"></imagedata>
						</imageobject>
					</mediaobject>
				</listitem>
			</orderedlist>
			<para>每次心跳过程中，ContainerAllocator会发送如下本地信息到RM端进行处理(处理逻辑是通过ApplicationMasterService服务来封装的，通过调用其allocate方法)：</para>
			<orderedlist>
				<listitem>
					<para>作业执行的进度信息；</para>
				</listitem>
				<listitem>
					<para>用于申请Container资源的ResourceRequest集合；</para>
					<para>这些ResourceRequest请求是在TaskAttempt状态机由NEW切换至UNASSIGNED时构建的，状态转换期间，其会触发CONTAINER_REQ事件来使ContainerAllocator进行回调处理。如果目标任务是MapTask立刻开始构建ResourceRequest(通过调用ScheduledRequests类的addMap方法)，否则将reduce任务加入到pending队列，等到恰当的时机在进行处理。</para>
					<para>Reduce任务的调度时机是通过如下方式计算出来的：</para>
					<itemizedlist make='bullet'>
						<listitem><para>首先已完成的Map任务数/Map任务总数应不小于mapreduce.job.reduce.slowstart.completedmaps配置；</para></listitem>
						<listitem>
							<para>其次，如果分配给Map任务的资源总量在使用上出现溢出，则限制用于部署Reduce任务的资源总量/App的总资源量应不大于yarn.app.mapreduce.am.job.reduce.rampup.limit配置；</para>
							<para>当App的可用资源量不足以部署一个Map任务时，会对Reduce所占用的资源进行抢占，将要抢占的任务数量是通过yarn.app.mapreduce.am.job.reduce.preemption.limit参数来控制的，默认参数值为0.5，表示最坏情况下所抢占的Reduce资源量会占作业总资源量的50%。 抢占过程主要是触发TaskAttemptEvent事件，事件类型为TA_KILL，以此来杀死目标Reduce任务并回收其所占用的资源来部署将要运行的Map任务。</para>
							<tip>在2.6版本之前，FairScheduler在App资源总量的计算上存在Bug，其headroom设置始终为0，导致Reduce资源被频繁抢占，详细可参考https://issues.apache.org/jira/browse/YARN-1959</tip>
						</listitem>
						<listitem><para>最后分配给Reduce的可用资源量应不小于mapreduce.reduce.memory.mb配置；</para></listitem>
					</itemizedlist>
					<para>针对每个要申请的Container，ContainerAllocator会构造出多个ResourceRequest来分别满足不同形式的资源申请(Data-local、Rack-local和Off-switch)，资源调度器在执行资源分配时，优先选择Data-local形式的ResourceRequest进行处理，其次是Rack-local和Off-switch，因此满足Data-local形式的Container会优先返回给ContainerAllocator。</para>
				</listitem>
				<listitem>
					<para>需要释放资源的Container集合；</para>
					<para>如果RM端返回的Container大小不符合使用规格，或者Container所在的NM已被AM加入黑名单，此时需要对这些Container做释放处理(通过调用containerNotAssigned方法)，待下次心跳时将需要释放的Container传递至RM端，由RM杀死其对应的RMContainer状态机实例并回收其所占用资源。</para>
					<para>除了以上情况，如果RM端返回了多余的Container计算资源，ContainerAllocator同样会做释放处理，这种情况主要是由于AM和RM的异步处理机制所造成的，产生的原因大致如下：</para>
					<para>首先RM端与AM端都分别维护了一个Map用来存储ResourceRequest数据集合，其中AM端的数据结构为(为便于引用，称之为remoteRequestsTable)：Map&lt;Priority, Map&lt;hostName, Map&lt;Resource, ResourceRequest>>>，RM端的数据结构为(为便于引用，称之为requests)：Map&lt;Priority, Map&lt;hostName, ResourceRequest>>，虽然两个Map存储的数据内容都为ResourceRequest，然而由于异步通信的原因导致在某一个时间点上，两个集合的数据内容并不完全一致。</para>
					<para>假设AM端构造了一条ResourceRequest申请，其numContainers属性值为1，通过心跳逻辑发送到RM端以后，RM首先将其保存到requests集合中，待NODE_UPDATE事件触发后在对其进行响应处理。数据保存的过程是以覆写的方式进行的(即新的ResourceRequest记录会覆盖掉以前的旧记录，而不是简单的对numContainers属性值进行追加，这也是造成数据不对称的主要原因所在，代码参考AppSchedulingInfo类的updateResourceRequests方法)。</para>
					<para>RM成功分配Container以后开始遍历requests集合，并对相关ResourceRequest的numContainers计数执行减1操作(代码参考AppSchedulingInfo类的allocate方法)，然后通过心跳逻辑将新分配的Container返回给AM端进行处理，以便其对remoteRequestsTable集合中对应的ResourceRequest记录执行同样的减1操作。如果在新分配的Container返回给AM之前，AM又新构造了一个ResourceRequest申请，并且hostname与之前的申请完全相同，那么此时便会产生数据不对称的现象。</para>
					<para>假设新构造的ResourceRequest申请为requestB，而之前的申请为requestA，requestB在发送给RM之前需要参考remoteRequestsTable集合中与之相应的requestA记录来确定其numContainers属性值。由于此时AM端还没有收到RM端新分配的Container，因此requestA的numContainers属性值依然为1(还没来得及执行减1操作)，而requestB需要在requestA的基础上对numContainers属性执行加1操作(代码参考RMContainerRequester类的addResourceRequest方法)，因此其numContainers属性值将变成2。待requestB发送到RM以后仍然以覆写的方式更新到requests集合，从而导致要申请的Container数量大于实际使用的数量(实际需要2个，但是总共申请了3个，requestA申请了一个，requestB申请了2个)。</para>
				</listitem>
				<listitem>
					<para>黑名单列表。</para>
					<para>如果在NM节点上运行失败的Task数量达到3个(通过mapreduce.job.maxtaskfailures.per.tracker参数指定)，AM会将该节点加入黑名单，在以后的调度中RM不再从该节点为其分配资源。</para>
				</listitem>
			</orderedlist>
			<para>心跳请求发送后，在RM端会通过ApplicationMasterService服务进行处理，待服务处理完毕后会向ContainerAllocator发送如下响应信息(参考ApplicationMasterService服务)，针对这些响应信息，ContainerAllocator会分别执行如下处理：</para>
			<orderedlist>
				<listitem>
					<para>针对RM端已运行结束的RMContainer</para>
					<para>如果RMContainer是正常结束退出的，触发TaskAttemptEvent事件，事件类型为TA_CONTAINER_COMPLETED，对NM端相应的Container执行清理操作；</para>
					<para>如果是非正常退出(如ABORT操作)，触发TaskAttemptEvent事件，事件类型为TA_KILL，开启新的TaskAttempt实例。</para>
				</listitem>
				<listitem>
					<para>针对运行状况发生变动的NM节点</para>
					<para>如果NM节点由可用变成了不可用，并且其上部署了一些Container正在执行Task任务，则杀死这些Container，然后开启新的TaskAttempt实例在运行正常的NM节点上重新执行。</para>
				</listitem>
				<listitem>
					<para>针对调度器新分配的Container，按照优先级由高到低的顺序依次执行加载操作</para>
					<para>按照所加载任务种类的不同，Container优先级可划分成3类，分别是：</para>
					<blockquote>
						<itemizedlist make='bullet'>
							<listitem><para>PRIORITY_FAST_FAIL_MAP：之前运行出错的Map任务；</para></listitem>
							<listitem><para>PRIORITY_MAP：全新的map任务；</para></listitem>
							<listitem><para>PRIORITY_REDUCE：reduce任务。</para></listitem>
						</itemizedlist>
					</blockquote>
					<para>其中PRIORITY_FAST_FAIL_MAP具有最高的优先级，会优先加载，其次是PRIORITY_REDUCE和PRIORITY_MAP。</para>
					<para>在Container加载之前，需要对申请它的ResourceRequests执行清理操作来防止Container资源的重复申请。清理办法十分简单，只需定位到指定的ResourceRequests，将其numContainers属性值-1即可，如果-1后值为0，将其从数据结构中移除。</para>
					<para>ResourceRequest成功清理后触发TaskAttemptEvent事件，事件类型为TA_ASSIGNED，开始尝试TaskContainer的加载操作(参考TaskAttempt状态机)。</para>
				</listitem>
			</orderedlist>
			<tip>
				<para>如果RM在分配Container的过程中，目标Container所属的NM执行了resync操作，那么AM与RM心跳通信过程中所获取的Container信息可能会存在问题(既在新分配的集合里，又在已完成的集合里)，因为在NM执行resync的过程中，目标RMContainer状态机会被kill，从而将其标识成运行结束的状态，而该Container恰恰又是新分配的，所以AM端的两个集合中(新分配集合、finish集合)都存在该Container。</para>
				<para>针对该类型的Container，AM在后续的处理过程中会存在一定的问题，假设Container-A属于该类型的Container，因为其在新分配的集合里，所以AM会对其执行加载操作，将其部署到目标NM上来运行任务。</para>
				<para>然而Container-A在目标NM上启动后会被马上执行Kill操作，因为NM和RM之间也存在着心跳通信的逻辑，由于RMContainer状态机在RM端已被杀死，NM端会级联清理与之对应的NMContainer(代码参考NodeStatusUpdaterImpl服务)。</para>
				<para>Container-A在被NM杀死之后依然会将其状态汇报给RM(通过ResourceTracker服务)，但由于RM端的RMContainer状态机实例已经进入了KILLED状态，已在无法正常响应CONTAINER_FINISHED事件。导致目标Container并没有加入RMAppAttempt的justFinishedContainers集合中。</para>
				<para>AM端主要通过与RM心跳通信来获知哪些Container已经运行结束从而将目标Task标识成对应的状态，这些运行结束的Container主要从RMAppAttempt的justFinishedContainers集合中获取，由于Container-A没有存入到该集合，导致AM再无法接收其运行结束的消息，从而一直等待直至Task运行超时(默认10分钟)。</para>
			</tip>
		</section>
		<section>
			<title>JobHistoryEventHandler服务</title>
			<para>JobHistoryEventHandler服务主要用来序列化JobHistoryEvent事件，将事件信息持久化到${yarn.app.mapreduce.am.staging-dir}/${jobId}/${jobId}_${attemptId}.jhist文件中进行存储，序列化过程是通过avro来实现的，以json形式保存，文件片段如下所示：</para>
			<programlistingco>
				<programlisting>
{
  "type":"AM_STARTED", <co id="co.eventwriter.type" linkends="co.note.eventwriter.type"/>
  "event":{ <co id="co.eventwriter.obj" linkends="co.note.eventwriter.obj"/>
    "org.apache.hadoop.mapreduce.jobhistory.AMStarted":{
      "applicationAttemptId":"appattempt_1392791047289_0002_000001",
      "startTime":1392858171813,
      "containerId":"container_1392791047289_0002_01_000001",
      "nodeManagerHost":"BJYZH2-HD-TEST-2086.jd.com",
      "nodeManagerPort":60013,
      "nodeManagerHttpPort":8042
    }
  }
}
				</programlisting>
				<calloutlist>
					<callout id="co.note.eventwriter.type" arearefs="co.eventwriter.type" ><para>type用来表示事件类型；</para></callout>
					<callout id="co.note.eventwriter.obj" arearefs="co.eventwriter.obj" ><para>event用于封装事件对象。</para></callout>
				</calloutlist>
			</programlistingco>
			<para>一、如果事件类型是AM_STARTED</para>
			<orderedlist>
				<listitem>
					<para>创建EventWriter实例用于序列化JobHistoryEvent事件；</para>
				</listitem>
				<listitem>
					<para>将作业配置信息写入到${yarn.app.mapreduce.am.staging-dir}/${jobId}/${jobId}_${attemptId}_conf.xml文件中。</para>
					<para>在通过JobHistoryServer界面查看作业配置时，所看到的内容便是从该配置文件中读取到的，但需要注意这只是AMContainer中的任务在加载时所采用的配置，而不一定是TaskContainer的运行配置，因为AMContainer和TaskContainer有可能隶属与不同的NodeManager，而如果NodeManager的配置不同，那么与job.xml合并所产生的job配置也将不一样。</para>
				</listitem>
			</orderedlist>
			<para>二、当JobSubmittedEvent事件触发时</para>
		</section>
		<section>
			<title>Speculator服务</title>
		</section>
		<section>
			<title>MRClientService服务?</title>
			<para>作为RPC服务用来响应JobClient请求，包括获取Job运行信息、诊断信息，响应kill命令杀死正在运行的Job</para>
		</section>
	</section>
</section>