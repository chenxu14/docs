<?xml version="1.0" encoding="UTF-8"?>
<section version="5.0" xmlns="http://docbook.org/ns/docbook"
	xmlns:xlink="http://www.w3.org/1999/xlink"
	xmlns:xi="http://www.w3.org/2001/XInclude"
	xmlns:ns5="http://www.w3.org/2000/svg"
	xmlns:ns4="http://www.w3.org/1998/Math/MathML"
	xmlns:ns3="http://www.w3.org/1999/xhtml"
	xmlns:db="http://docbook.org/ns/docbook">
	<title>HMaster实现</title>
	<section>
		<title>启动关闭</title>
		<section>
			<title>启动过程</title>
			<para>HMaster的启动包含两方面的操作，分别是初始化准备工作和RegionServer加载，由于HMaster本身是可以作为RS来部署Region的，因此它的启动过程也要包含RS的启动逻辑。这两项操作是通过不同的线程独立完成的，其中RS的加载可参考RegionServer启动关闭章节，而这里主要看HMaster的初始化操作。</para>
			<para>执行初始化操作的前提是HMaster处于Active状态，在启动的初始阶段，其会不断尝试在ZK中创建/hbase/master节点，如果创建成功自己将进入Active，否则需要对该节点进行监听，基于进程锁机制在合适的时机将自己切换成Active(代码参考ActiveMasterManager类的blockUntilBecomingActiveMaster方法)。</para>
			<para>进入Active以后开始执行初始化操作，初始化逻辑大致如下(代码参考HMaster的finishActiveMasterInitialization方法)：</para>
			<orderedlist>
				<listitem>
					<para>初始化MasterFileSystem对象实例。</para>
					<para>MasterFileSystem对象在初始化过程中会去检测hbase的temp目录，如果其下含有表格路径信息，会将这些表格数据移动到archive路径下。如果要移动的表格数据非常庞大会造成master的启动过程非常缓慢，因此在master启动之前最好先清理temp路径下的无用数据。</para>
				</listitem>
				<listitem>
					<para>预加载所有表格定义信息，如果集群开启了hbase.master.preload.tabledescriptors配置(默认为true)。</para>
				</listitem>
				<listitem>
					<para>释放所有之前ActiveMaster所占据的表格锁，通过调用TableLockManager的reapWriteLocks方法。</para>
				</listitem>
				<listitem>
					<para>初始化LoadBalancer，AssignmentManager等服务并注册Listener用于监听ZK节点的相关事件。</para>
					<para>所注册的监听器包括：</para>
					<itemizedlist make='bullet'>
						<listitem>
							<para>SplitOrMergeTracker</para>
							<para>监听拆分和合并功能是否开启(HBASE-15128)，监听目录为/hbase/switch/split和/hbase/switch/merge。</para>
						</listitem>
						<listitem>
							<para>LoadBalancerTracker</para>
							<para>监听负载均衡功能是否开启，监听目录为/hbase/balancer。</para>
						</listitem>
						<listitem>
							<para>RegionNormalizerTracker</para>
							<para>监听normalizer功能是否开启(HBASE-13103)，监听目录为/hbase/normalizer。</para>
						</listitem>
						<listitem>
							<para>RegionServerTracker</para>
							<para>监听目前存活的RS节点，监听目录为/hbase/rs。</para>
						</listitem>
						<listitem>
							<para>DrainingServerTracker</para>
							<para>监听退役的RS节点，针对已退役的节点Master不在向其分配新的Region，但是已有Region会正常工作(HBASE-4298)。监听目录为/hbase/draining。</para>
						</listitem>
					</itemizedlist>
					<para>监听器注册成功以后调用ClusterStatusTracker类的setClusterUp方法在ZK中创建/hbase/running节点，以便通知RS端开始执行初始化操作。同时注册预定义的Procedure，包括：SnapshotManager(用于快照管理)和MasterFlushTableProcedureManager(用于flush表格)。</para>
				</listitem>
				<listitem>
					<para>初始化Master端的协处理器，通过实例化MasterCoprocessorHost。</para>
				</listitem>
				<listitem>
					<para>开启如下线程池实例(名称&amp;线程数量)。</para>
					<para>(1)MASTER_OPEN_REGION(5)</para>
					<para>(2)MASTER_CLOSE_REGION(5)</para>
					<para>(3)MASTER_SERVER_OPERATIONS(5)</para>
					<para>(4)MASTER_META_SERVER_OPERATIONS(5)</para>
					<para>(5)M_LOG_REPLAY_OPS(10)</para>
					<para>(6)MASTER_TABLE_OPERATIONS(1)</para>
				</listitem>
				<listitem>
					<para>等待RS进行注册，直至已注册的RS数量达到hbase.master.wait.on.regionservers.mintostart参数要求(代码参考ServerManager类的waitForRegionServers方法)。</para>
				</listitem>
				<listitem>
					<para>等待Master端的RS初始化完成并处于Online状态，如果hbase.balancer.tablesOnMaster配置了相关表格。</para>
				</listitem>
				<listitem>
					<para>对metaRegion进行分配。</para>
					<para>如果metaRegion之前所在的RS没有处于online状态，需要对metaRegion执行logReplay操作，详细参考MasterMetaBootstrap类的assignMeta方法。</para>
				</listitem>
				<listitem>
					<para>对userRegion进行分配(通过AssignmentManager类的joinCluster方法)，详细参考Region分配章节。</para>
				</listitem>
				<listitem>
					<para>针对之前异常结束退出的RS执行logReplay操作(该操作通过AM的failoverCleanupDone来唤醒)。</para>
					<para>如果RS是正常结束退出的(比如执行了shutdown命令或kill操作)，那么其在退出时会对HLog执行归档操作(将其移动到/hbase/oldWALs目录)。而如果是通过kill -9强制杀死的，或者由于拆分/合并失败而引发abort退出的，那么HLog并不会被归档。Master在启动的时候需要对这些未归档HLog执行logReplay操作来恢复之前遗失的数据。</para>
				</listitem>
				<listitem>
					<para>对如下服务线程进行调度。</para>
					<itemizedlist make='bullet'>
						<listitem>
							<para>LogCleaner，定期清理/hbase/oldWALs目录下的归档日志。</para>
							<para>默认每隔60秒执行一次清理，时间是通过hbase.master.cleaner.interval参数指定的。日志可清理的前提是满足TimeToLiveLogCleaner类(hbase.master.logcleaner.plugins参数指定)的isLogDeletable判断：即距离日志的最后一次修改时间已经过去了10分钟(时间通过hbase.master.logcleaner.ttl参数指定)。</para>
						</listitem>
						<listitem>
							<para>HFileCleaner，定期清理/hbase/archive目录下的归档HFile。</para>
							<para>可清理的前提是目标HFile满足BaseFileCleanerDelegate类的isFileDeletable判断，如果集群启用了快照功能(hbase.snapshot.enabled)，则归档文件不可清理，详细参考SnapshotHFileCleaner类以及SnapshotManager的checkSnapshotSupport方法。</para>
						</listitem>
						<listitem>
							<para>ClusterStatusChore</para>
							<para>定期向Balancer提供当前集群的运行状态，以便其在虚拟集群上模拟负载均衡操作。</para>
						</listitem>
						<listitem>
							<para>BalancerChore</para>
							<para>定期执行balance操作，默认每隔300秒执行一次(通过hbase.balancer.period参数指定)。</para>
						</listitem>
						<listitem>
							<para>RegionNormalizerChore</para>
							<para>TODO HBASE-13103</para>
						</listitem>
						<listitem>
							<para>CatalogJanitor</para>
							<para>定期扫描hbase:meta表来回收垃圾Region(已经做了拆分或者已被合并)。</para>
						</listitem>
						<listitem>
							<para>PeriodicDoMetrics</para>
							<para>定期更新master端的metric信息。</para>
						</listitem>
						<listitem>
							<para>ExpiredMobFileCleanerChore</para>
							<para>TODO HBASE-11339</para>
						</listitem>
					</itemizedlist>
				</listitem>
				<listitem>
					<para>分配meta副本，如果hbase.meta.replica.count配置大于1，并对多余的metaRegion副本执行unassign操作。</para>
				</listitem>
				<listitem>
					<para>开启QuotaManager进行配额管理，代码参考initQuotaManager方法。</para>
				</listitem>
			</orderedlist>
		</section>
		<section>
			<title>启动加速</title>
			<para>2.0之前的HBase版本在HMaster启动阶段有几个过程是非常耗时的，如果集群的Region数量庞大则耗时表现会更加明显，其中包括：</para>
			<orderedlist>
				<listitem>
					<para>AssignmentManager#joinCluster操作</para>
					<para>在此阶段需要遍历ZK路径下的每一个/hbase/table子节点，用来获取处于ENABLING和DISABLING状态的表格信息，并将之前执行enable或disable失败的表格做重新的处理，如果表格数量庞大会导致该阶段异常耗时，通过观察线上集群的日志输出，发现20000表格需要将近3分钟的处理时间，相关日志如下：master.AssignmentManager: Joined the cluster in 168794ms.</para>
				</listitem>
				<listitem>
					<para>RegionLocationFinder#scheduleFullRefresh操作</para>
					<para>在此阶段需要遍历每一个Region的hdfs存储目录，用来评估该Region的数据本地性权重。如果Region的体量非常庞大，同样会导致该阶段的执行异常耗时。通过观察线上集群，30万体量的Region加载完成需要将近20分钟的时间，而在这段时间由于HMaster没有处于initialized状态，所有DDL操作将不可用。</para>
				</listitem>
			</orderedlist>
			<para>针对这两类问题社区已经提供了相应的修复办法，修复细节大致如下：</para>
			<orderedlist>
				<listitem>
					<para>针对耗时阶段一</para>
					<para>hbase从1.1.x版本开始起，Table的enable和disable操作都是通过Procedure-V2来进行管理的，针对执行失败的操作是有自动恢复能力的，HMaster无需在进行介入处理。为此，社区在2.0版本的时候提供了相应的修复补丁来bypass这一环节，相关JIRA可参考HBASE-13823。</para>
				</listitem>
				<listitem>
					<para>针对耗时阶段二</para>
					<para>RegionLocationFinder主要用来评估负载均衡过程中每个Region的数据本地性迁移成本，考虑到该过程比较耗时，并且有些集群的部署本身就是计算与存储分离的，不需要考虑数据本地性的问题。因此在执行负载均衡的时候可以忽略这项维度，这样HMaster在启动的时候便可以绕过RegionLocationFinder#scheduleFullRefresh方法不去执行，从而加快HMatser的启动效率。为此社区在1.4版本的时候引入了一个新的配置项hbase.master.balancer.uselocality(默认值为true)，用来控制本地性维度是否开启，相关JIRA可以参考HBASE-18478。</para>
					<para>如果负载均衡过程中对数据本地性是有强需求的，我们也可以采用另外一种处理策略：即在HMaster初始化阶段先暂时绕过RegionLocationFinder#scheduleFullRefresh方法的执行，待HMaster初始化完成之后在去执行该操作，从而不影响线上DDL操作的进行(比如kylin的构建cube操作)，相关JIRA可参考HBASE-20768。</para>
				</listitem>
			</orderedlist>
			<tip>在执行热切启动之前先通过hbck检测一下集群的状态是否正常，并对/hbase/.tmp目录进行清理。如果master视角与RS视角所管理的Region状态不一致，AssignmentManager#assignAllUserRegions方法的执行可能会出问题，将RS端已下线的Region重新ENABLE。</tip>
		</section>
		<section>
			<title>关闭过程</title>
			<para>可以通过两种方式来对HMaster进行关闭，一种是通过kill命令或hbase-daemon.sh脚本，该方式与RS的关闭逻辑类似，触发ShutdownHookThread线程进行回调处理；另一种方式是通过调用HBaseAdmin的shutdown方法(或执行hbase master stop命令)。需要注意的是该方式不只会关闭HMaster，还会级联关闭所有的backupMaster和RS，实现逻辑如下(代码可参考HMaster的shutdown方法)：</para>
			<orderedlist>
				<listitem>
					<para>首先执行RS的关闭逻辑，通过调用ServerManager的shutdownCluster方法。</para>
				</listitem>
				<listitem>
					<para>然后删除ZK上的/hbase/running节点，以此来通知RS和backupMaster执行关闭操作。</para>
					<para>RS通过调用isClusterUp方法来判断集群是否已经shutdown，从而决定是否关闭自己；而backupMaster则通过调用ActiveMasterManager的nodeDeleted方法来进行回调。</para>
				</listitem>
			</orderedlist>
		</section>
	</section>
	<xi:include href="balance_section.xml"/>
	<xi:include href="assign_section.xml"/>
	<xi:include href="lifecycle_section.xml"/>
	<xi:include href="tableLock_section.xml"/>
	<section>
		<title>通信服务</title>
		<para>RegionServer与HMaster的通信逻辑主要通过RegionServerStatusService服务来封装，服务发布在HMaster端，供RegionServer端调用使用，服务对外声明了如下实用方法：</para>
		<itemizedlist make='bullet'>
			<listitem>
				<para>getLastFlushedSequenceId</para>
				<para>获取指定Region最后一次执行flush时的sequenceId，该信息是通过心跳通信逻辑由RegionServer传递至HMaster端的，在执行Region恢复的时候需要用到该信息(详细参考Region恢复章节)。</para>
			</listitem>
			<listitem>
				<para>regionServerReport</para>
				<para>RegionServer通过该方法与HMaster进行心跳通信，心跳时间通过hbase.regionserver.msginterval参数来设置，默认为3秒。通信过程中RegionServer主要向HMaster传递如下信息：</para>
				<orderedlist>
					<listitem><para>RegionServer的每秒请求量以及总请求量；</para></listitem>
					<listitem><para>RegionServer所使用的堆内存大小以及最大堆内存；</para></listitem>
					<listitem><para>RegionServer所使用的协处理器列表；</para></listitem>
					<listitem><para>RegionServer中每个Region的负载情况，包括：Store数、StoreFile文件数、StoreFile总大小、MemStore大小、文件索引大小、读/写请求数、最后一次执行flush时的sequenceId等；</para></listitem>
					<listitem><para>Replication信息，包括从哪些源节点接受HLog数据，以及将HLog数据发送至哪个目标节点。</para></listitem>
				</orderedlist>
			</listitem>
			<listitem>
				<para>regionServerStartup</para>
				<para>RegionServer启动后会通过该方法向HMaster进行汇报，从而将自己注入到ServerManager容器中，方法执行后，HMaster端会进行如下处理：</para>
				<para>首先检测RegionServer的启动时间与当前HMaster的系统时间是否存在比较大的差异，如果时间差大于10秒(hbase.master.warningclockskew参数设置)，打印如下警告信息：</para>
				<blockquote><para>Reported time for server {serverName} is out of sync with master ...</para></blockquote>
				<para>而如果时间差大于30秒(hbase.master.maxclockskew参数设置)，将直接抛出ClockOutOfSyncException异常，RegionServer的注册将以失败而告终。</para>
				<para>接着检测该RegionServer是否在死节点列表里，如果RegionServer是死后重启，将其从死节点列表中移除。</para>
				<para>最后检测该RegionServer是否已经存在于online列表里，如果是则比较它们的startCode值，保留startCode比较大的记录。</para>
			</listitem>
			<listitem>
				<para>reportRSFatalError</para>
				<para>当RegionServer运行出错以后通过该方法向HMaster进行汇报，HMaster收到消息后会打印如下error信息：Region server {sn} reported a fatal error: {errorText} ...</para>
			</listitem>
			<listitem>
				<para>reportRegionStateTransition</para>
				<para>TODO</para>
			</listitem>
		</itemizedlist>
	</section>
</section>