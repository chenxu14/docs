<?xml version="1.0" encoding="UTF-8"?>
<section version="5.0" xmlns="http://docbook.org/ns/docbook"
	xmlns:xlink="http://www.w3.org/1999/xlink"
	xmlns:xi="http://www.w3.org/2001/XInclude"
	xmlns:ns5="http://www.w3.org/2000/svg"
	xmlns:ns4="http://www.w3.org/1998/Math/MathML"
	xmlns:ns3="http://www.w3.org/1999/xhtml"
	xmlns:db="http://docbook.org/ns/docbook">
	<title>RMApp状态机</title>
	<para>App生命周期状态转换图如下图所示：</para>
	<mediaobject>
		<imageobject>
			<imagedata contentdepth="100%" width="100%" scalefit="1" fileref="../media/yarn/app-lifecycle.png"></imagedata>
		</imageobject>
	</mediaobject>
	<para>状态转移信息如下所示：</para>
	<itemizedlist make='bullet'>
		<listitem>
			<para>状态转换：NEW-->NEW_SAVING</para>
			<para>触发事件：START</para>
			<blockquote><para>RM收到SubmitApplicationRequest请求时会触发该事件，代码可参考ClientRMService服务的submitApplication方法。</para></blockquote>
			<para>回调处理：通过RMAppNewlySavingTransition类来封装，</para>
			<blockquote><para>将当前RMApp实例保存到RMStateStore中以便RM重启时进行recover处理。</para></blockquote>
		</listitem>
		<listitem>
			<para>状态转换：NEW-->SUBMITTED | ACCEPTED | FINISHED | FAILED | KILLED | FINAL_SAVING</para>
			<para>触发事件：RECOVER</para>
			<blockquote><para>RM重启后或热切时触发该事件，代码可参考RMAppManager类的recover方法。</para></blockquote>
			<para>回调处理：通过RMAppRecoveredTransition类来封装。</para>
			<blockquote>
				<para>主要用于恢复RM重启或热切前正在运行的作业，具体的恢复逻辑可参考作业恢复事件流章节。</para>
			</blockquote>
		</listitem>
		<listitem>
			<para>状态转换：NEW_SAVING-->SUBMITTED</para>
			<para>触发事件：APP_NEW_SAVED(RMApp成功保存后触发)</para>
			<para>回调处理：通过AddApplicationToSchedulerTransition类来封装。</para>
			<blockquote>
				<para>处理过程主要是触发APP_ADDED事件，来使调度器进行相关处理，详细参考调度器中有关APP_ADDED事件的处理逻辑。</para>
			</blockquote>
		</listitem>
		<listitem>
			<para>状态转换：SUBMITTED-->ACCEPTED</para>
			<para>触发事件：APP_ACCEPTED(调度器处理完APP_ADDED事件之后触发)</para>
			<para>回调处理：通过StartAppAttemptTransition类来封装。</para>
			<blockquote>
				<para>处理过程主要是开启RMAppAttempt状态机实例，并通过触发START事件来使其进行回调处理。</para>
			</blockquote>
		</listitem>
		<listitem>
			<para>状态转换：ACCEPTED-->RUNNING</para>
			<para>触发事件：ATTEMPT_REGISTERED</para>
			<blockquote><para>AM成功注册时触发，通过ApplicationMasterService服务的registerApplicationMaster方法。</para></blockquote>
			<para>回调处理：不作处理。</para>
		</listitem>
		<listitem>
			<para>状态转换：RUNNING-->RUNNING</para>
			<para>触发事件：NODE_UPDATE</para>
			<blockquote><para>当有RMNode的运行状态发生变动时触发该事件，比如NM由可用变为了不可用，具体可参考NodesListManager服务。</para></blockquote>
			<para>回调处理：通过RMAppNodeUpdateTransition类来封装。</para>
			<blockquote>
				<para>将目标RMNode保存至updatedNodes集合中，待ApplicationMaster下次心跳通信时将其作为response返回到AM端进行处理(AM端的处理逻辑可参考MapReduce应用的ContainerAllocator服务，对应代码为RMContainerAllocator类的handleUpdatedNodes方法)。</para>
			</blockquote>
		</listitem>
		<listitem>
			<para>状态转换：RUNNING-->FINAL_SAVING</para>
			<para>触发事件：ATTEMPT_UNREGISTERED</para>
			<blockquote><para>AM运行结束时触发，通过ApplicationMasterService服务的finishApplicationMaster方法</para></blockquote>
			<para>回调处理：通过FinalSavingTransition类来封装。</para>
			<blockquote>
				<para>构造ApplicationState用于封装RMApp运行结束时的状态，并将其保存到RMStateStore中进行存储。</para>
			</blockquote>
		</listitem>
		<listitem>
			<para>状态转换：FINAL_SAVING-->FINISHING</para>
			<para>触发事件：APP_UPDATE_SAVED(ApplicationState成功保存到RMStateStore时触发该事件)</para>
			<para>回调处理：通过FinalStateSavedTransition类来封装。</para>
			<blockquote>
				<para>如果RMApp进入FINAL_SAVING状态是由于触发ATTEMPT_UNREGISTERED事件引起的，调用AttemptUnregisteredTransition类进行处理，处理过程主要是统计RMApp的运行结束时间。</para>
			</blockquote>
		</listitem>
		<listitem>
			<para>状态转换：FINISHING-->FINISHED</para>
			<para>触发事件：ATTEMPT_FINISHED(RMAppAttempt成功运行结束后触发)</para>
			<para>回调处理：通过AppFinishedTransition类来封装。</para>
			<blockquote>
				<para>首先针对每一个参与该RMApp部署的RMNode触发RMNodeEvent事件(事件类型为CLEANUP_APP)，使RMNode状态机做相应处理。</para>
				<para>然后触发APP_REMOVED事件，使调度器进行相关处理。</para>
				<para>最后触发APP_COMPLETED事件，使RMAppManager进行相关处理。包括：记录audit日志，打印作业运行汇总，并检测已完成的作业是否超过yarn.resourcemanager.max-completed-applications阈值。</para>
			</blockquote>
		</listitem>
	</itemizedlist>
</section>