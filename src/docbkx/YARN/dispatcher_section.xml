<?xml version="1.0" encoding="UTF-8"?>
<section version="5.0" xmlns="http://docbook.org/ns/docbook"
	xmlns:xlink="http://www.w3.org/1999/xlink"
	xmlns:xi="http://www.w3.org/2001/XInclude"
	xmlns:ns5="http://www.w3.org/2000/svg"
	xmlns:ns4="http://www.w3.org/1998/Math/MathML"
	xmlns:ns3="http://www.w3.org/1999/xhtml"
	xmlns:db="http://docbook.org/ns/docbook">
	<title>事件驱动机制</title>
	<para>YARN框架中的很多操作都是以事件驱动的形式进行的，其对外提供了Dispatcher接口用来作为事件调度器。调度器结构如图所示：</para>
	<figure id='dispatcher.architecture'>
		<title>事件调度器结构</title>
		<mediaobject>
			<imageobject>
				<imagedata contentdepth="80%" width="80%" fileref="../media/yarn/dispatcher-architecture.jpg"></imagedata>
			</imageobject>
		</mediaobject>
	</figure>
	<para>如图所示，Dispatcher基于生产者-消费者模式来设计。</para>
	<blockquote>
		<para>GenericEventHandler负责生产事件，并将事件加入生产队列；</para>
		<para>eventHandlingThread负责消费事件，消费过程中，通过遍历事件处理器表格(Handlers)找到事件对应的处理器，然后通过处理器的handle方法执行与事件相关的操作(事件处理器都会实现EventHandler接口)。</para>
	</blockquote>
	<para>同时Dispatcher接口对外声明两个方法，作用如下：</para>
	<blockquote>
		<para>getEventHandler方法用于获取事件生产对象GenericEventHandler，通过该对象向生产队列中添加Event；</para>
		<para>register方法用于注册事件处理器到Handlers中。</para>
	</blockquote>
	<para>YARN框架中每一种事件类型都会对应一个处理器，他们之间的映射关系如下：</para>
	<table frame='all'>
		<title>事件处理器</title>
		<tgroup cols='2' align='left' colsep='1' rowsep='1'>
			<colspec colname='c1' colwidth="15em"/>
			<colspec colname='c2'/>
			<thead>
				<row>
					<entry>事件类型</entry>
					<entry>事件处理器</entry>
				</row>
			</thead>
			<tbody>
				<row><entry namest="c1" nameend="c2" align="left">ResourceManager组件中事件类型</entry></row>
				<row>
					<entry>RMStateStoreEventType</entry>
					<entry>RMStateStore.ForwardingEventHandler(保存App的状态以便容灾恢复)</entry>
				</row>
				<row>
					<entry>SchedulerEventType</entry>
					<entry>ResourceManager.SchedulerEventDispatcher(资源调度)</entry>
				</row>
				<row>
					<entry>RMAppEventType</entry>
					<entry>ResourceManager.ApplicationEventDispatcher(通过状态机维护RMApp的生命周期)</entry>
				</row>
				<row>
					<entry>RMAppAttempEventType</entry>
					<entry>ResourceManager.ApplicationAttempEventDIspatcher(通过状态机维护RMAppAttemp的生命周期)</entry>
				</row>
				<row>
					<entry>NodesListManagerEventType</entry>
					<entry>NodesListManager</entry>
				</row>
				<row>
					<entry>RMNodeEventType</entry>
					<entry>ResourceManager.NodeEventDispatcher(通过状态机维护RMNode的声明周期)</entry>
				</row>
				<row>
					<entry>AMLauncherEventType</entry>
					<entry>ApplicationMasterLauncher(负责启动ApplicationMaster)</entry>
				</row>
				<row><entry namest="c1" nameend="c2" align="left">NodeManager组件中事件类型</entry></row>
				<row>
					<entry>ContainerManagerEventType</entry>
					<entry>ContainerManagerImpl</entry>
				</row>
				<row>
					<entry>NodeManagerEventType</entry>
					<entry>NodeManager</entry>
				</row>
				<row>
					<entry>LogHandlerEventType</entry>
					<entry>NonAggregatingLogHandler(默认情况下)</entry>
				</row>
				<row>
					<entry>LocalizationEventType</entry>
					<entry>ResourceLocalizationService(从hdfs下载Container运行需要的资源)</entry>
				</row>
			</tbody>
		</tgroup>
	</table>
	<!-- 
	<section>
		<title>TaskContainer分配</title>
		<para>事件触发流程如图所示：</para>
		<mediaobject>
			<imageobject>
				<imagedata contentdepth="42.5%" scalefit="1" fileref="../media/yarn/taskassign-event.png"></imagedata>
			</imageobject>
		</mediaobject>
		<para>事件流程说明：</para>
		<orderedlist>
			<listitem>
				<para>作业初始化</para>
				<para>MRAppMaster服务启动后会触发JobEvent事件，事件类型为JOB_INIT，开始执行作业初始化操作；</para>
				<para>初始化过程中主要是判断作业应该以哪种方式进行部署(uber还是分布式)，并且针对每一个输入源切片构建MapTask(详细参考Job状态机)</para>
			</listitem>
			<listitem>
				<para>作业启动前的准备工作</para>
				<para>初始化操作结束后开始执行作业启动前的准备工作(创建job工作目录)，这个过程是通过触发JOB_SETUP事件来完成的；</para>
				<tip>需要注意的是作业的初始化操作和准备操作并不是异步执行的，需要等待初始化工作结束之后才能执行准备操作。</tip>
			</listitem>
			<listitem>
				<para>开启Task状态机实例</para>
				<para>准备工作结束后开始对Task进行调度处理，调度方法是通过触发T_SCHEDULE事件来开启Task状态机实例</para>
			</listitem>
			<listitem>
				<para>开启TaskAttempt状态机实例</para>
				<para>Task的执行可能需要经过多次尝试才会成功，针对每一次尝试使用TaskAttempt来封装，其实例化过程是通过TA_SCHEDULE事件来触发的。</para>
			</listitem>
			<listitem>
				<para>构造ResourceRequest用于申请TaskContainer</para>
				<para>TA_SCHEDULE事件触发后开始构造构造ResourceRequest对象用于申请Container计算资源，ResourceRequest的构造是通过触发CONTAINER_REQ事件来实现的，事件触发后ContainerAllocator服务会进行相关的回调处理，通过与RM心跳通信来完成Container的分配逻辑(参考ContainerAllocator服务)。</para>
			</listitem>
		</orderedlist>
		<tip>TaskContainer的加载过程同AMContainer类似，都是通过ContainerManager服务的startContainers方法来实现的，具体的加载逻辑可参考ContainerManager服务，事件流程可参考AMContainer加载事件流。</tip>
	</section>
	-->
	<section>
		<title>AM Container分配</title>
		<para>分配事件流程如图所示：</para>
		<mediaobject>
			<imageobject>
				<imagedata contentdepth="100%" width="100%" scalefit="1" fileref="../media/yarn/scheduler-event.png"></imagedata>
			</imageobject>
		</mediaobject>
		<orderedlist>
			<listitem>
				<para>作业提交</para>
				<para>客户端通过ApplicationClientProtocol代理服务向RM提交作业。</para>
			</listitem>
			<listitem>
				<para>开启RMApp状态机实例</para>
				<para>作业提交后，RM端会通过RMAppManager服务来响应客户端的提交申请，响应过程主要是开启RMApp状态机实例并触发START事件使其做相应处理。</para>
			</listitem>
			<listitem>
				<para>RMApp状态保存</para>	
				<para>RMApp状态机实例开启后，首先调用RMStateStore的storeNewApplication方法将RMApp的状态进行保存以便容灾恢复。</para>
				<tip>在2.7.3版本之前，storeNewApplication方法被声明成同步，这样在RMStateStore执行存储操作时(storeApplicationStateInternal方法)，由于其对象锁被抢占，RMApp状态机所在线程将会进入等待状态，级联造成AsyncDispatcher的事件队列阻塞(因为事件需要按照触发顺序串行处理)，造成的影响是集群的资源使用率虽然没有达到百分之百，但是依然出现了作业pending的现象，详细可参考YARN-4398。</tip>
			</listitem>
			<listitem>
				<para>向调度器触发APP_ADD事件，以便在调度器端构建出对应的SchedulerApplication实例。</para>
			</listitem>
			<listitem>
				<para>开启RMAppAttempt状态机实例</para>
				<para>RMApp的部署可能需要经过多次尝试才会成功，针对每次尝试使用RMAppAttempt状态机实例进行封装。</para>	
			</listitem>
			<listitem>
				<para>向调度器触发APP_ATTEMPT_ADDED事件，以便在调度器端构建出对应的SchedulerApplicationAttempt实例，并将其提交至目标队列中等待调度。</para>
			</listitem>
			<listitem>
				<para>构造ResourceRequest用于申请AMContainer</para>
				<para>接受到调度器端的ATTEMPT_ADDED事件之后开始构造ResourceRequest用于申请AMContainer，并将其注入到调度器端的SchedulerApplicationAttempt实例中(通过调度器的allocate方法)。</para>
			</listitem>
			<listitem>
				<para>响应ResourceRequest申请来完成Container分配</para>
				<para>Container是在RM与NM不断的心跳通信过程中来完成分配处理的，心跳逻辑通过NodeStatusUpdater服务开启(参考NodeStatusUpdater服务)，每次心跳都会触发NODE_UPDATE事件，调度器接受到事件以后开始响应ResourceRequest申请来完成Container的分配处理(参考资源调度器)。</para>
			</listitem>
			<listitem>
				<para>RMAppAttempt状态保存</para>
				<para>Container成功申请后会触发START事件使RMContainer状态机做相应处理，事件回调函数中会接连触发CONTAINER_ALLOCATED事件将RMAppAttempt状态机实例进行保存(通过RMStateStore的storeNewApplicationAttempt方法)以便容灾恢复。</para>
			</listitem>
		</orderedlist>
	</section>
	<section>
		<title>AM Container加载</title>
		<para>AMContainer的加载是通过触发LAUNCH事件来实现的(RMAppAttempt成功保存到RMStateStore之后会触发该事件)，事件触发后ApplicationMasterLauncher服务会开启相应的AMLauncher线程，线程在运行期间会调用ContainerManager服务的startContainers方法将Container进行启动(参考ContainerManager服务)，启动细节大致如下：</para>
		<orderedlist>
			<listitem>
				<para>Application初始化</para>
				<mediaobject>
					<imageobject>
						<imagedata contentdepth="100%" width="100%" scalefit="1" fileref="../media/yarn/app_lanch_1.png"></imagedata>
					</imageobject>
				</mediaobject>
				<para>初始化操作是通过触发INIT_APPLICATION事件来实现的，当执行ContainerManager服务的startContainers方法时，方法会首先判断要启动的Container所属Application是否成功初始化，如果没有则触发该事件，事件触发后首先通知LogHandler做好日志准备工作(参考LogHandler服务)，然后注册LocalResourcesTracker用来跟踪PRIVATE资源和APPLICATION资源的获取情况(参考ResourceLocalizationService服务)。</para>
			</listitem>
			<listitem>
				<para>AMContainer初始化及加载</para>
				<mediaobject>
					<imageobject>
						<imagedata contentdepth="100%" width="100%" scalefit="1" fileref="../media/yarn/app_lanch_2.png"></imagedata>
					</imageobject>
				</mediaobject>
				<itemizedlist make='bullet'>
					<listitem>
						<para>Application初始化成功后开始执行AMContainer的初始化操作，该操作是通过触发INIT_CONTAINER事件来实现的，针对每一个要启动的Container，ContainerManager服务在执行过程中都会触发该事件，事件触发后首先通知辅助服务做好相应的准备工作(参考辅助服务)，然后触发INIT_CONTAINER_RESOURCES事件，开始从HDFS下载Container运行所需要的资源(job.xml、封装job的jar包以及输入源切片等信息)，下载逻辑是通过ResourceLocalizationService服务封装的(参考ResourceLocalizationService服务)。</para>
					</listitem>
					<listitem>
						<para>Container运行所需要的资源下载成功后开始对其执行加载操作，加载逻辑是通过触发LAUNCH_CONTAINER事件来实现的，事件触发后ContainersLauncher服务会做好相应的回调处理来完成Container加载(参考ContainersLauncher服务)。</para>
					</listitem>
				</itemizedlist>
			</listitem>
		</orderedlist>
	</section>
	<section>
		<title>App终止事件流</title>
		<orderedlist>
			<listitem>
				<para>首先将RMApp状态机实例从RMStateStore中进行移除，整个过程是通过执行ApplicationMasterService服务的finishApplicationMaster方法来触发的，具体的事件流程如图所示：</para>
				<mediaobject>
					<imageobject>
						<imagedata contentdepth="100%" width="100%" scalefit="1" fileref="../media/yarn/stop-app1.png"></imagedata>
					</imageobject>
				</mediaobject>
				<itemizedlist make='bullet'>
					<listitem><para>在NM端，ApplicationMaster服务以RPC的方式远程调用ApplicationMasterService的finishApplicationMaster方法，向RM端告知AM已处理完成；</para></listitem>
					<listitem>
						<para>在RM端，通过一连串的事件传递，最后由RMApp状态机触发UPDATE_APP事件，将自身状态在RMStateStore中进行保存。</para>
						<para>默认情况下RMStateStore会保存10000个已完成的App，该阈值可通过yarn.resourcemanager.state-store.max-completed-applications参数来声明。如果RMStateStore保存的App实例数比较多，在重启或热切的时候需要花费更长的时间来执行recover操作。</para>
					</listitem>
				</itemizedlist>
			</listitem>
			<listitem>
				<para>其次，对App执行RM端清理，具体事件流程如图所示：</para>
				<mediaobject>
					<imageobject>
						<imagedata contentdepth="100%" width="100%" scalefit="1" fileref="../media/yarn/stop-app2.png"></imagedata>
					</imageobject>
				</mediaobject>
				<itemizedlist make='bullet'>
					<listitem><para>当ApplicationMaster执行System.exit()方法退出时，会触发CONTAINER_EXITED_WITH_SUCCESS事件，执行对AMContainer的清理操作(参考ContainersLauncher服务)，清理结束后将自身标记为COMPLETE状态，在通过心跳通信逻辑传递至RM端进行处理；</para></listitem>
					<listitem><para>RM端收到心跳申请后，会将NM端运行结束的Container保存到与之对应的RMNode状态机实例中进行存储。然后调度器在从RMNode中拉取这些Container(通过其pullContainerUpdates方法)，并通过触发FINISHED事件来使其对应的RMContainer进行处理。</para></listitem>
					<listitem>
						<para>RMContainer在处理过程中会接连触发CONTAINER_FINISHED事件来使RMAppAttempt进行处理，处理内容如下(代码参考ContainerFinishedAtFinalSavingTransition)：</para>
						<para>(1)首先更新目标ApplicationAttemptState在RMStateStore中的状态为FINISHED；</para>
						<para>(2)然后将目标AppAttempt从AMLivelinessMonitor监控中移除；</para>
						<para>(3)接着触发ATTEMPT_FINISHED事件使RMApp进行处理，处理过程主要是触发CLEANUP_APP事件，以此来向RMNode注入待清理的App。同时触发APP_REMOVED事件，使调度器做相应处理；</para>
						<para>(4)最后触发APP_ATTEMPT_REMOVED事件使调度器进行处理，处理过程中会杀死RMApp所部署的每一个RMContainer状态机实例，并将其保存到RMNode中进行存储(通过触发CLEANUP_CONTAINER事件)，待下次心跳时将这些Container传递至NM端进行清理。</para>
					</listitem>
					<listitem><para>待NM端的心跳申请到达之后，从对应的RMNode状态机中取出这些待清理的App和Container集合，并作为response返回到NM端进行处理(具体参考NodeStatusUpdater服务)：</para></listitem>
				</itemizedlist>
			</listitem>
			<listitem>
				<para>最后，对App执行NM端清理，具体事件流程如图所示：</para>
				<mediaobject>
					<imageobject>
						<imagedata contentdepth="100%" width="100%" scalefit="1" fileref="../media/yarn/stop-app3.png"></imagedata>
					</imageobject>
				</mediaobject>
				<itemizedlist make='bullet'>
					<listitem><para>在RM端，RMNode状态机记录了所有待清理的App与Container集合，每次心跳会传递至NM端进行处理(参考NodeStatusUpdater服务)；</para></listitem>
					<listitem><para>NM收到这些信息后，针对每一个要清理的Container会触发KILL_CONTAINER事件来杀死该Container进程(通过ContainersLauncher服务来实现)，同时会接着触发CLEANUP_CONTAINER_RESOURCES事件对Container运行所依赖的文件资源进行清理(通过ResourceLocalizationService服务来实现)，待清理工作完成之后在通知LogHandler与辅助服务做最后的收尾；</para></listitem>
					<listitem><para>除此之外针对每一个待清理的App，NodeStatusUpdater服务还会触发FINISH_APPLICATION事件来使Application状态机进行相应的处理，处理过程中如果该App还有未运行结束的Container，则触发KILL_CONTAINER事件对其进行杀死，否则触发DESTROY_APPLICATION_RESOURCES事件来清理App运行所依赖的资源(文件、辅助服务等)。</para></listitem>
				</itemizedlist>
			</listitem>
		</orderedlist>
	</section>
	<section>
		<title>作业恢复事件流</title>
		<para>作业恢复逻辑主要发生在RM重启或执行热切操作时触发(HA模式下)，实现目的是为了确保在RM重启后，之前部署的作业状态不会丢失，可在新RM实例上继续运行。</para>
		<para>恢复过程主要是调用ResourceManager的recover方法来实现，其会将RMStateStore中所存储的作业实例恢复到之前的运行状态，每个作业的恢复过程大致如下：</para>
		<mediaobject>
			<imageobject>
				<imagedata contentdepth="100%" width="100%" scalefit="1" fileref="../media/yarn/recover.png"></imagedata>
			</imageobject>
		</mediaobject>
		<orderedlist>
			<listitem>
				<para>首先还原出每个作业的状态机实例。</para>
				<para>针对每一个待恢复的作业，系统会去调用RMAppManager类的recoverApplication方法来将其进行恢复。方法执行后会首先创建出RMAppImpl状态机实例，并将其加入到RM的上下文环境中以便于调度器对其进行引用，然后开始对目标RMAppImpl执行recover方法，以便恢复其之前运行的状态信息，包括：启动时间、结束时间、运行诊断及FINAL状态(如果App尚未运行结束其FINAL状态为null)，这些信息全部记录在RMStateStore中进行存储。</para>
				<para>RMAppImpl状态恢复以后开始尝试构造RMAppAttempt状态机实例，针对作业之前所运行的每次尝试都需要开启该状态机实例，然后调用recover方法来对最后的运行实例做状态恢复处理，恢复逻辑同样是将每个RMAppAttempt实例还原成RMStateStore中记录的状态。</para>
			</listitem>
			<listitem>
				<para>将状态还原之后的作业重新加入调度。</para>
				<para>该逻辑是通过触发RECOVER事件来实现的，事件触发后RMAppImpl会进行如下回调处理：</para>
				<itemizedlist make='bullet'>
					<listitem><para>首先触发APP_ADDED事件并通知调度器这是recover操作(不用在触发APP_ACCEPTED事件给RMApp状态机)。</para></listitem>
					<listitem>
						<para>针对每一个作业尝试(RMAppAttempt)，触发RECOVER事件使其进行处理(代码参考AttemptRecoveredTransition钩子函数)。</para>
						<para>一、如果目标RMAppAttempt是作业当前已开启的最后一次尝试。</para>
						<para>首先判断其是否已经处于了FINAL状态(FINISHED、FAILED或KILLED)，如果条件满足并且其所对应的RMApp并没有运行结束，则执行BaseFinalTransition钩子函数将当前RMAppAttempt切换至目标FINAL状态，同时触发相应的事件使RMAppImpl进行回调处理(开启新的作业尝试或运行结束)。</para>
						<para>如果RMAppAttempt没有进入FINAL状态，那么有可能是以下原因引起的(因为这时还没有触发FinalSavingTransition钩子函数，具体参考RMAppAttempt状态机)：</para>
						<para>(1)AMContainer还没有完成加载</para>
						<para>(2)AMContainer加载后还没来得及向RM进行注册(调用ApplicationMasterService的registerApplicationMaster方法)</para>
						<para>(3)AMContainer还没有运行完成(执行注销操作，通过调用ApplicationMasterService的unregisterApplicationMaster方法)</para>
						<para>这时需要进行如下处理：</para>
						<para>首先判断RM是否开启了yarn.resourcemanager.work-preserving-recovery.enabled配置。如果条件满足调用ApplicationMasterService服务的registerAppAttempt方法，将当前RMAppAttempt进行注册，然后触发APP_ATTEMPT_ADDED事件，使调度器进行相应处理。</para>
						<para>最后将当前RMAppAttempt切换至LAUNCHED状态，并通过AMLivelinessMonitor来监控其存活，如果出现以下状况时，在将其标记为FAILED。</para>
						<para>(1)AMLivelinessMonitor监控超时</para>
						<para>(2)NM心跳显示目标AMContainer已运行结束</para>
						<para>二、如果目标RMAppAttempt并不是作业的最后一次尝试</para>
						<para>那么其之前一定处于FINAL状态(FINISHED、FAILED或KILLED)，此时并不需要做任何恢复处理，只需将RMAppAttempt切换至目标FINAL状态即可。</para>
					</listitem>
					<listitem><para>最后将当前RMAppImpl状态机实例切换至ACCEPTED状态，表明作业已经进入调度阶段。</para></listitem>
				</itemizedlist>
			</listitem>
		</orderedlist>
	</section>
</section>