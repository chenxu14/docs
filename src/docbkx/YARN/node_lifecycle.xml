<?xml version="1.0" encoding="UTF-8"?>
<section version="5.0" xmlns="http://docbook.org/ns/docbook"
	xmlns:xlink="http://www.w3.org/1999/xlink"
	xmlns:xi="http://www.w3.org/2001/XInclude"
	xmlns:ns5="http://www.w3.org/2000/svg"
	xmlns:ns4="http://www.w3.org/1998/Math/MathML"
	xmlns:ns3="http://www.w3.org/1999/xhtml"
	xmlns:db="http://docbook.org/ns/docbook">
	<title>RMNode状态机</title>
	<para>RMNode状态机主要用于封装RM视角每个NodeManager节点的运行状态，其状态转换图如下所示：</para>
	<mediaobject>
		<imageobject>
			<imagedata contentdepth="100%" width="100%" scalefit="1" fileref="../media/yarn/node-lifecycle.png"></imagedata>
		</imageobject>
	</mediaobject>
	<itemizedlist make='bullet'>
		<listitem>
			<para>状态转换：NEW-->RUNNING</para>
			<para>触发事件：STARTED</para>
			<blockquote><para>NM注册时触发，通过调用ResourceTrackerService类的registerNodeManager方法。</para></blockquote>
			<para>回调处理：通过AddNodeTransition类来封装。</para>
			<blockquote><para>触发SchedulerEvent事件，事件类型为NODE_ADDED，使调度器做相应处理。</para></blockquote>
		</listitem>
		<listitem>
			<para>状态转换：RUNNING-->RUNNING</para>
			<para>触发事件：CLEANUP_CONTAINER(部署在其上的RMContainer被杀死时触发，参考RMContainer状态机)</para>
			<para>回调处理：通过CleanUpContainerTransition类来封装。</para>
			<blockquote><para>将事件传递过来的Container加入待清理集合中，等到NM与RM心跳通信时作为response返回给NM进行清理(处理过程参考NodeStatusUpdater服务)。</para></blockquote>
		</listitem>
		<listitem>
			<para>状态转换：RUNNING-->RUNNING</para>
			<para>触发事件：CLEANUP_APP(RMApp运行结束时触发，参考RMApp状态机)</para>
			<para>回调处理：通过CleanUpAppTransition类来封装。</para>
			<blockquote><para>将事件传递过来的App加入待清理集合中，等到NM与RM心跳通信时作为response返回给NM进行清理(处理过程参考NodeStatusUpdater服务)。</para></blockquote>
		</listitem>
		<listitem>
			<para>状态转换：RUNNING-->RUNNING</para>
			<para>触发事件：RECONNECTED(NM端执行resync操作时会触发该事件，参考ResourceTrackerService服务)</para>
			<para>回调处理：通过ReconnectNodeTransition类来封装。</para>
			<blockquote><para>首先触发NODE_REMOVED事件来通知调度器杀死目标RMNode上所部署的所有RNContainer状态机实例，然后触发NODE_ADDED事件将目标RMNode重新加入集群。</para></blockquote>
		</listitem>
		<listitem>
			<para>状态转换：RUNNING-->RUNNING</para>
			<para>触发事件：FINISHED_CONTAINERS_PULLED_BY_AM</para>
			<blockquote><para>RM将运行结束的TaskContainer汇报给AM之后触发该事件。</para></blockquote>
			<para>回调处理：通过AddContainersToBeRemovedFromNMTransition类来封装。</para>
			<blockquote><para>将事件传递过来的Containers加入containersToBeRemovedFromNM集合，待目标NM下一次心跳时作为response返回到NM端执行清理。</para></blockquote>
		</listitem>
		<listitem>
			<para>状态转换：RUNNING-->RUNNING | UNHEALTHY</para>
			<para>触发事件：STATUS_UPDATE(NM与RM心跳通信时触发)</para>
			<para>回调处理：通过StatusUpdateWhenHealthyTransition类来封装。</para>
			<blockquote>
			<para>首先由事件对象获取当前NM节点的健康状态信息(NM与RM心跳过程中会将自身的节点健康状态信息发送给RM，RM在通过事件驱动转发给RMNode状态机，详细参考ResourceTrackerService服务)，如果节点处于unhealthy状态：</para>
			<orderedlist>
				<listitem><para>触发SchedulerEvent事件，事件类型为NODE_REMOVED，使调度器进行相应处理；</para></listitem>
				<listitem><para>触发NodesListManagerEvent事件，事件类型为NODE_UNUSABLE，使NodesListManager服务进行相应处理。</para></listitem>
				<listitem><para>将RMNode切换成UNHEALTHY状态。</para></listitem>
			</orderedlist>
			<para>否则触发SchedulerEvent事件，事件类型为NODE_UPDATE，使调度器进行相应处理。</para>
			</blockquote>
		</listitem>
		<listitem>
			<para>状态转换：RUNNING-->LOST</para>
			<para>触发事件：EXPIRE(NMLivelinessMonitor监控超时之后触发)</para>
			<para>回调处理：通过DeactivateNodeTransition类来封装。</para>
			<blockquote>
			<orderedlist>
				<listitem><para>触发SchedulerEvent事件，事件类型为NODE_REMOVED，使调度器进行相应处理；</para></listitem>
				<listitem><para>触发NodesListManagerEvent事件，事件类型为NODE_UNUSABLE，使NodesListManager服务进行相应处理。</para></listitem>
			</orderedlist>
			</blockquote>
		</listitem>
		<listitem>
			<para>状态转换：RUNNING-->DECOMMISSIONED</para>
			<para>触发事件：DECOMMISSION(节点加入yarn.resourcemanager.nodes.exclude-path配置时触发)</para>
			<para>回调处理：通过DeactivateNodeTransition类来封装。</para>
			<blockquote>
			<orderedlist>
				<listitem><para>触发SchedulerEvent事件，事件类型为NODE_REMOVED，使调度器进行相应处理；</para></listitem>
				<listitem><para>触发NodesListManagerEvent事件，事件类型为NODE_UNUSABLE，使NodesListManager服务进行相应处理。</para></listitem>
			</orderedlist>
			</blockquote>
		</listitem>
		<listitem>
			<para>状态转换：RUNNING-->REBOOTED</para>
			<para>触发事件：REBOOTING</para>
			<blockquote><para>当NM与RM心跳不同步时触发该事件，代码参考ResourceTrackerService服务的nodeHeartbeat方法。</para></blockquote>
			<para>回调处理：通过DeactivateNodeTransition类来封装。</para>
			<blockquote>
			<orderedlist>
				<listitem><para>触发SchedulerEvent事件，事件类型为NODE_REMOVED，使调度器进行相应处理；</para></listitem>
				<listitem><para>触发NodesListManagerEvent事件，事件类型为NODE_UNUSABLE，使NodesListManager服务进行相应处理。</para></listitem>
			</orderedlist>
			</blockquote>
		</listitem>
		<listitem>
			<para>状态转换：UNHEALTHY-->RUNNING | UNHEALTHY</para>
			<para>触发事件：STATUS_UPDATE(NM与RM心跳通信时触发)</para>
			<para>回调处理：通过StatusUpdateWhenUnHealthyTransition类来封装。</para>
			<blockquote>
			<para>同样首先由事件对象获取当前NM节点的健康状态信息，如果节点处于healthy状态：</para>
			<orderedlist>
				<listitem><para>触发SchedulerEvent事件，事件类型为NODE_ADDED，使调度器进行相应处理；</para></listitem>
				<listitem><para>触发NodesListManagerEvent事件，事件类型为NODE_USABLE，使NodesListManager进行相应处理(参考NodesListManager服务)；</para></listitem>
				<listitem><para>将RMNode切换成RUNNING状态。</para></listitem>
			</orderedlist>
			<para>否则不做任何处理。</para>
			</blockquote>
		</listitem>
	</itemizedlist>
</section>