<?xml version="1.0" encoding="UTF-8"?>
<section version="5.0" xmlns="http://docbook.org/ns/docbook"
	xmlns:xlink="http://www.w3.org/1999/xlink"
	xmlns:xi="http://www.w3.org/2001/XInclude"
	xmlns:ns5="http://www.w3.org/2000/svg"
	xmlns:ns4="http://www.w3.org/1998/Math/MathML"
	xmlns:ns3="http://www.w3.org/1999/xhtml"
	xmlns:db="http://docbook.org/ns/docbook">
	<title>RM状态恢复</title>
	<para>在RM端需要对如下状态机实例进行恢复：RMApp、RMAppAttempt、RMNode以及RMContainer。其中有关RMApp和RMAppAttempt的恢复逻辑可参考作业恢复事件流章节，而RMNode状态机实例会在NM执行resync操作时重新生成(代码参考ResourceTrackerService服务的registerNodeManager方法)，因此这里主要看RMContainer状态机如何恢复。</para>
	<section>
		<title>RMContainer恢复</title>
		<para>RMContainer的恢复逻辑主要在NM执行resync操作时触发，在执行resync操作的最后阶段，NM会去调用ResourceTracker服务的registerNodeManager方法来将自身进行重新注册，同时将recover后的Container状态一并传递到RM端进行处理(代码参考NodeStatusUpdater服务的registerWithRM方法)。</para>
		<para>RM端收到注册消息以后，会去执行调度器的recoverContainersOnNode方法进行处理，方法在执行过程中会首先判断RM是否开启了yarn.resourcemanager.work-preserving-recovery.enabled配置，如果没有直接返回，否则调用AbstractYarnScheduler的recoverAndCreateContainer方法来还原出每一个Container所对应的RMContainer状态机实例，并对其触发RECOVER事件使其进行回调处理。回调处理内容是通过ContainerRecoveredTransition类来封装的，细节如下：</para>
		<itemizedlist make='bullet'>
			<listitem>
				<para>如果目标Container的状态显示其正在运行。</para>
				<para>触发APP_RUNNING_ON_NODE事件，将运行该Container的Node节点加入其所属RMApp的ranNodes集合，并将RMContainer状态机切换至Running状态。</para>
			</listitem>
			<listitem>
				<para>如果目标Container的状态显示其已经运行结束。</para>
				<para>调用FinishedTransition将RMContainer状态机切换至COMPLETED状态。</para>
			</listitem>
		</itemizedlist>
		<para>RMContainer状态机实例恢复之后，开始处理与调度器相关的状态恢复逻辑：</para>
		<orderedlist>
			<listitem><para>首先定位到NM所对应的SchedulerNode，并将该RMContainer所占用的资源量从其节点资源总量中削减出去(代码参考SchedulerNode类的recoverContainer方法)，在将该RMContainer加入到调度节点launchedContainers集合中。</para></listitem>
			<listitem><para>然后由目标Container定位到其所属任务队列(Queue)，并对其执行recoverContainer处理(目前FairScheduler调度器不做任何处理)。</para></listitem>
			<listitem><para>最后由目标Container定位到其所属的SchedulerApplicationAttempt，并将Container所占用的资源与其资源总量进行叠加(代码参考SchedulerApplicationAttempt类的recoverContainer方法)，同时将该Container加入liveContainers集合。</para></listitem>
		</orderedlist>
	</section>
	<section>
		<title>ResourceRequest恢复</title>
		<para>ResourceRequest的恢复逻辑需要依赖AM端的相应处理。RM重启后，AMContainer进程并不会结束退出，如果NM端开启了work-preserving配置。因此其依然可以保持与RM端的心跳通信逻辑，但是已有AM的注册信息将会丢失，因为这部分信息并没有在RM端进行持久化存储。所以当AM再次与RM心跳时，RM将会通知其执行resync操作(通过抛出ApplicationMasterNotRegisteredException异常，具体参考ApplicationMasterService服务章节)。</para>
		<para>AM端捕获到ApplicationMasterNotRegisteredException异常后需要进行如下处理以便work-preserving功能能够继续：</para>
		<orderedlist>
			<listitem>
				<para>向RM端进行重新注册。</para>
				<para>通过调用ApplicationMasterService的registerApplicationMaster方法。</para>
			</listitem>
			<listitem>
				<para>将AM端所构造的ResourceRequest重新发送到RM端进行处理。</para>
				<para>拿MapReduce应用举例，AM端所构造的ResourceRequest主要通过RMContainerRequestor来封装，其内部声明了remoteRequestsTable数据结构用于封装所有尚未得到响应的ResourceRequest。当resync操作触发时，会去调用RMContainerRequestor类的addOutstandingRequestOnResync方法将这些ResourceRequest重新发送到RM端进行处理。</para>
			</listitem>
		</orderedlist>
		<para>如果AM是基于AMRMClient来与RM进行通信的，那么以上逻辑会被自动封装，详细可参考AMRMClientImpl类的allocate方法。</para>
	</section>
	<section>
		<title>CompleteContainer恢复</title>
		<para>NM端运行结束的TaskContainer主要通过如下方式汇报到AM端：</para>
		<para>(1)借助于NM与RM的心跳通信逻辑，将运行结束的TaskContainer从NM端传递至RM端；</para>
		<para>(2)借助于RM与AM的心跳通信逻辑，将NM传递过来的TaskContainer信息汇报至AM端。</para>
		<para>由于NM与RM的心跳以及AM与RM的心跳都是异步的过程，因此RM重启后有可能TaskContainer的状态还未来得及向AM进行汇报便已经丢失，为此需要做如下重构处理：</para>
		<orderedlist>
			<listitem>
				<para>NM将运行结束的TaskContainer汇报给RM之后，不再对这些TaskContainer记录进行清理，而是将其放入pendingCompletedContainers集合(代码参考NodeStatusUpdater服务的getContainerStatuses方法)。这样当RM重启后这些TaskContainer便可以重新汇报给RM，在通过RM汇报给AM，以免造成TaskContainer运行状态丢失。</para>
			</listitem>
			<listitem>
				<para>RM将运行结束的TaskContainer汇报给AM之后，将其加入containersToBeRemovedFromNM集合，并作为ack响应返回给NM端进行清理(代码可参考RMNode状态机有关FINISHED_CONTAINERS_PULLED_BY_AM事件的回调处理以及ResourceTrackerService服务的nodeHeartBeat方法)。</para>
			</listitem>
		</orderedlist>
		<para>重构之后AM端有可能多次收到某个TaskContainer运行结束的事件，比如RM将目标TaskContainer汇报给AM之后还没来得及向NM进行反馈便被重启，这时便会将目标TaskContainer二次汇报给AM。</para>
	</section>
</section>